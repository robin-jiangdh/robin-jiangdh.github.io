<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>http://blog.robinjiang.com/</id>
	<title>知行志</title>
	<link rel="self" href="http://blog.robinjiang.com/" />
	<rights>2020</rights>
	<updated>2020-04-20T07:12:07Z</updated>
	<subtitle>知行合一!</subtitle>
	<entry>
		<id>http://blog.robinjiang.com/posts/2020/04/2020-04-13-string-class-sealed</id>
		<title>C#中是否可以继承String类?</title>
		<link href="http://blog.robinjiang.com/posts/2020/04/2020-04-13-string-class-sealed" />
		<updated>2020-04-13T00:00:00Z</updated>
		<content>&lt;p&gt;C#中是否可以继承String类?&lt;/p&gt;
&lt;p&gt;答：String类是sealed类故不可以继承。&lt;/p&gt;
&lt;p&gt;当对一个类应用 sealed 修饰符时，&lt;strong&gt;此修饰符会阻止其他类从该类继承&lt;/strong&gt;。 在下面的示例中，类 HoverTree 从类 Keleyi 继承，但是任何类都不能从类 HoverTree 继承。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Keleyi {} 
sealed class HoverTree : Keleyi {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以在重写基类中的虚方法或虚属性的方法或属性上使用 sealed 修饰符。 这将使您能够允许类从您的类继承，并防止它们重写特定的虚方法或虚属性。&lt;/p&gt;
</content>
		<summary>&lt;p&gt;C#中是否可以继承String类?&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</id>
		<title>wyam:基于dotnet的静态内容生成器</title>
		<link href="http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit" />
		<updated>2020-03-10T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;劝退指南，目前作者团队已经放弃wyam去开发另外一个项目了&lt;a href="https://github.com/statiqdev"&gt;statiq&lt;/a&gt;,也是一个静态内容生成器，目前该项目还不完整，demo都还不完善&lt;/p&gt;
&lt;p&gt;目前本博就是基于wyam的，如果需要demo的话，可以去这里看&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;本博客 &lt;a href="https://github.com/robin-jiangdh/robin-jiangdh.github.io"&gt;https://github.com/robin-jiangdh/robin-jiangdh.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方网站： &lt;a href="https://github.com/Wyamio/Wyam.web"&gt;https://github.com/Wyamio/Wyam.web&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id="wyam"&gt;Wyam的介绍&lt;/h2&gt;
&lt;p&gt;Wyam.io官网上的自我介绍基本上把Wyam是什么说的很清楚了，我就简单在这里翻译一下。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Wyam是与众不同的。它不是Jekyll的克隆（并不代表Jekyll有任何问题），它不是设计来生成博客的（虽然也能很好的胜任此任务）。Waym是一个静态内容生成器，可以用于生成网站、文档、电子书和其他更多的内容。由于它的所有东西都是通过很多灵活的模块（你也可以编写自己的模块）串在一起，所以唯一的限制是你的想象力。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;自带吐槽技能啊，这个Wyam对标的有点像docfx，不过目标跨的太大，扯着蛋了，后面又另起炉灶了，不过如果你只是用blog功能的话还是可以的，目前算是功能完善&lt;/p&gt;
&lt;p&gt;update 2020-03-24:&lt;/p&gt;
&lt;p&gt;用了两周，目前图片，标签系统或多或少有点bug，tags真心一团糟，我fork了一份自己在维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在它的特性当中，尤其让我看中的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/configuration"&gt;配置文件&lt;/a&gt;使用C#脚本写就，这完全是得益于Roslyn的强大&lt;/li&gt;
&lt;li&gt;简单直接的&lt;a href="http://wyam.io/modules/meta"&gt;元数据&lt;/a&gt;使用方式&lt;/li&gt;
&lt;li&gt;支持多种模板引擎和语言，尤其直接内置&lt;a href="http://wyam.io/modules/razor"&gt;Razor&lt;/a&gt;的支持（且Razor的支持是基于ASP.NET MVC 6的源代码的，未来会支持TagHelper） 。当然也有Markdown支持或者扩展自己的模板语言支持。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/usage"&gt;集成Web Server&lt;/a&gt;方便在编写模板的时候进行预览&lt;/li&gt;
&lt;li&gt;完全&lt;a href="http://wyam.io/getting-started/configuration#nuget"&gt;支持Nuget&lt;/a&gt;，可以在执行生成的过程中，自动下载依赖的Nuget包&lt;/li&gt;
&lt;li&gt;更为重要的，它支持&lt;a href="http://wyam.io/knowledgebase/embedded-use"&gt;嵌入运行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;相对完整清晰的文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Waym其实借鉴了现有其他静态内容生成器的优点和设计，比如FrontMatter的支持（通过Yaml实现）。目前还只是&lt;a href="https://github.com/Wyamio/Wyam/releases/tag/v2.2.9"&gt;v2.2.9&lt;/a&gt;，但是功能完成度还是比较高了，并且你也可以直接pull request参与贡献。源代码地址是：https://github.com/Wyamio/Wyam&lt;/p&gt;
</content>
		<summary>&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2020/03/2020-01-10-about-static-content-generator</id>
		<title>关于静态内容生成器和托管环境</title>
		<link href="http://blog.robinjiang.com/posts/2020/03/2020-01-10-about-static-content-generator" />
		<updated>2020-03-10T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;如何选用适用的静态内容生成器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</id>
		<title>《如何阅读一本书》读书笔记:关于Paper的阅读-2020年版</title>
		<link href="http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book" />
		<updated>2020-03-10T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一直在读分布相关的paper，毕业好多年，分布式的领域水真的太深了~，然后读paper各种卡壳，没办法重新翻出这本经典稳固一遍，然后根据stanford的文献整理了这篇博客&lt;/p&gt;
&lt;p&gt;&lt;a href="http://web.stanford.edu/class/cs245/readings/how-to-read-a-paper.pdf"&gt;how-to-read-a-paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍了一种阅读paper方法，帮助大家提高读paper的速度和效率。&lt;/p&gt;
&lt;h2 id="the-three-pass-approach"&gt;三遍阅读法(THE THREE-PASS APPROACH)&lt;/h2&gt;
&lt;p&gt;paper需要读三遍，每一遍都有不同的目标。 第一遍建立一个大体的印象，第二遍把握重要内容，第三遍深入理解。&lt;/p&gt;
&lt;h3 id="the-first-pass"&gt;第一遍(The first pass)&lt;/h3&gt;
&lt;p&gt;第一遍的重点是要快，花五到十分钟快速浏览一遍，获得一个全景印象。 关注如下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仔细阅读标题、摘要、简介(the title, abstract, and introduction)&lt;/li&gt;
&lt;li&gt;阅读章节和子章节的标题(the section and sub-section headings)&lt;/li&gt;
&lt;li&gt;扫一眼数学内容(the mathematical content)，了解理论基础&lt;/li&gt;
&lt;li&gt;阅读结论(the conclusions)&lt;/li&gt;
&lt;li&gt;浏览参考文献(the references)，勾选读过的paper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结束之后，回答5个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类型(Category): 评估(measurement)、系统分析(analysis)、研究原型(research prototype)&lt;/li&gt;
&lt;li&gt;上下文(Context): 相关论文、理论基础&lt;/li&gt;
&lt;li&gt;正确性(Correctness): 假设都成立吗？&lt;/li&gt;
&lt;li&gt;贡献(Contributions)&lt;/li&gt;
&lt;li&gt;清晰度(Clarity): 写的好吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个时候要决定是否继续阅读？是否感兴趣，是否关注这个研究领域，作者是否做了无效的假设。 同样的，如果你自己写paper，也要写好摘要和章节标题，如果读者在五分钟内找不到要点，可能就不会继续阅读了。&lt;/p&gt;
&lt;h3 id="the-second-pass"&gt;第二遍(The second pass)&lt;/h3&gt;
&lt;p&gt;第二遍的重点是要精，仔细阅读每一部分内容，但是注意不要陷入细节。 把自己当成评审员，记下要点、不理解的内容、想问作者的问题，在空白处写下评论。 重点关注图表和插图是否存在错误，这往往是决定一篇paper是否真正优秀的关键。 标注没有读过的参考文献，以便进一步阅读。&lt;/p&gt;
&lt;p&gt;这一遍通常要花费一个小时以上，这个时候应该掌握了paper的内容，可以有足够的论据总结出paper的主旨。 如果这篇paper只是有兴趣，但不是重点研究的领域，到这个程度就可以了。&lt;/p&gt;
&lt;p&gt;有时也有可能没有读懂，这有可能是因为不熟悉这个领域，也可能是论文本身写的不好，也可能是累了。 这个是时候可以有三种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暂时搁置&lt;/li&gt;
&lt;li&gt;了解背景材料后重新阅读&lt;/li&gt;
&lt;li&gt;坚持继续读&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="the-third-pass"&gt;第三遍(The third pass)&lt;/h3&gt;
&lt;p&gt;第三遍的关键是尝试重新实现一遍(virtually reimplement the paper)。 按照作者的假设，提出自己的想法，重新设计实现方案，并与原文的方案进行比较。 关注每一个细节，挑战每一个假设，记录下整个思路，并将有用的证明和技术加入到自己的工具库中。&lt;/p&gt;
&lt;p&gt;通过这样的方式，能够自己从头重建整个系统。 同时可以发现原文存在的问题：能指出隐含的假设，遗漏的实验和潜在的问题。&lt;/p&gt;
&lt;h2 id="literature-survey"&gt;文献分析(literature survey)&lt;/h2&gt;
&lt;p&gt;想深入了解一个领域，仅仅阅读一篇paper是不够的，可能需要读数十篇。 这时需要通过文献分析的方法找到合适的paper，也有三个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的关键词，使用&lt;a href="https://link.zhihu.com/?target=https%3A//scholar.google.com/"&gt;Google Scholar&lt;/a&gt;或&lt;a href="https://link.zhihu.com/?target=https%3A//citeseerx.ist.psu.edu/index"&gt;CiteSeer&lt;/a&gt; 找到该领域最近被引用最多的三到五篇paper&lt;/li&gt;
&lt;li&gt;找到参考文献中引用量最多的作者，他们是这个领域最重要的研究人员，关注他们的最近发布的paper和conferences&lt;/li&gt;
&lt;li&gt;访问这些top conferences的网站，找到最近的高质量paper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反复重复这几个步骤，不断找出这个领域的最重要paper并阅读，不断总结归纳。&lt;/p&gt;
</content>
		<summary>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2019/12/2019-12-22-aspnetcore-middleware-and-pipeline</id>
		<title>ASP.NET CORE 管道模型和中间件</title>
		<link href="http://blog.robinjiang.com/posts/2019/12/2019-12-22-aspnetcore-middleware-and-pipeline" />
		<updated>2019-12-22T00:00:00Z</updated>
		<content>&lt;h2 id="asp.net"&gt;ASP.NET 管道模型&lt;/h2&gt;
&lt;p&gt;请求进入ASP.NET 工作进程后，由进程创建HttpWorkRequest 对象，封装此次请求有关的所有信息，然后进入HttpRuntime 类进行进一步的处理。HttpRuntime 通过请求信息创建HttpContext 上下文对象，此对象将贯穿整个管道，直到响应结束。同时创建或从应用程序池里初始化一个HttpApplication对象，由此对象开始处理之前注册的多个HttpModule。之后调用HandlerFactory 创建Handler处理程序，最终处理此次请求内容，生存响应返回。
&lt;img src="https://blog.robinjiang.com/posts/asset/2019-12-22-aspnetcore-middleware-and-pipeline/aspnet-pipeline.jpg" class="img-fluid" alt="ASP.NET 管道模型.png" /&gt;&lt;/p&gt;
&lt;p&gt;管道架构异常复杂，同时不具备热插拔的功能。由于这套流程相对固定，对于特定的业务场景优化难度加大。&lt;/p&gt;
&lt;h2 id="aspnetcore"&gt;aspnetcore下的管道模型&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2019-12-22-aspnetcore-middleware-and-pipeline/aspnetcore-request-pipeline.png" class="img-fluid" alt="request-pipeline" /&gt;&lt;/p&gt;
&lt;p&gt;回归web的本质，就是请求与响应而已。
中间件本质上就是一个类型为 Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt; 的委托对象；
简单来说，中间件就是一个处理http请求和响应的组件，多个中间件构成了请求处理管道，每个中间件都可以选择处理结束，还是继续传递给管道中的下一个中间件，以此串联形成请求管道。&lt;/p&gt;
&lt;p&gt;实际编码实现上，提供了一个Imiddleware的接口定义&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="usemiddleware"&gt;UseMiddleware&lt;/h3&gt;
&lt;p&gt;使用UseMiddleware扩展方法使用IMiddleware时，需要注意你的IMiddleware中间件需要注册到DI中&lt;/p&gt;
</content>
		<summary>&lt;p&gt;请求进入ASP.NET 工作进程后，由进程创建HttpWorkRequest 对象，封装此次请求有关的所有信息，然后进入HttpRuntime 类进行进一步的处理。HttpRuntime 通过请求信息创建HttpContext 上下文对象，此对象将贯穿整个管道，直到响应结束。同时创建或从应用程序池里初始化一个HttpApplication对象，由此对象开始处理之前注册的多个HttpModule。之后调用HandlerFactory 创建Handler处理程序，最终处理此次请求内容，生存响应返回。
&lt;img src="https://blog.robinjiang.com/posts/asset/2019-12-22-aspnetcore-middleware-and-pipeline/aspnet-pipeline.jpg" class="img-fluid" alt="ASP.NET 管道模型.png"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2019/12/2019-12-21-netcore-start-process</id>
		<title>AspNetCore启动流程概述</title>
		<link href="http://blog.robinjiang.com/posts/2019/12/2019-12-21-netcore-start-process" />
		<updated>2019-12-21T00:00:00Z</updated>
		<content>&lt;p&gt;aspnetcore 应用程序，是一个拥有内置的Self-hosted的WebServer,用于处理外部请求。大部分情况下以控制台应用的方式实现子托管（Self-Hosted）。
相对于传统的aspnet 提供的大而全的设计，aspnetcore以最小化抽象设计为原则，以扩展(中间件)方式提供的易用性扩展来实现更高程度的按需使用。
在ASP.NET Core应用中通过配置并启动一个Host来完成应用程序的启动和其生命周期的管理。而Host的主要的职责就是Web Server的配置和Pilpeline（请求处理管道）的构建。
在应用中主要通过 构造一个IHostBuilder 的抽象对象来负责(通过build()方法)创建一个Ihost实例。并最终通过Ihost下的run()方法来启动这个实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IHostBuilder &amp;gt; IHost&amp;gt;Run()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;期间设计两个核心的概念IHostbuilder和Ihost&lt;/p&gt;
&lt;h1 id="ihostbuilder"&gt;IHostBuilder&lt;/h1&gt;
&lt;p&gt;可以理解为为了启动host而准备的一些配置文件或行为，提供默认注册行为CreateDefaultBuilder和相关扩展ConfigureWebHostDefaults，以及其他一些配置入口。&lt;/p&gt;
&lt;h3 id="createdefaultbuilder"&gt;CreateDefaultBuilder相关&lt;/h3&gt;
&lt;p&gt;大部分都是配置系统相关的api&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UseContentRoot&lt;/li&gt;
&lt;li&gt;ConfigureHostConfiguration&lt;/li&gt;
&lt;li&gt;ConfigureAppConfiguration&lt;/li&gt;
&lt;li&gt;ConfigureLogging&lt;/li&gt;
&lt;li&gt;UseDefaultServiceProvider&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="configurewebhostdefaults"&gt;ConfigureWebHostDefaults&lt;/h3&gt;
&lt;p&gt;配置webserver的默认行为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UseStaticWebAssets&lt;/li&gt;
&lt;li&gt;UseKestrel/UseIIS&lt;/li&gt;
&lt;li&gt;ConfigureServices 服务中间件的注册，包括路由中间件&lt;/li&gt;
&lt;li&gt;UseStartup 程序Startup 启动，该启动类中可以注册中间件、扩展第三方中间件，以及相关应用程序配置的处理等&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="build"&gt;Build()&lt;/h1&gt;
&lt;p&gt;核心要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BuildHostConfiguration();-&amp;gt;围绕ConfigureHostConfiguration的一系列配置回调-&amp;gt;执行ConfigureHostConfiguration&lt;/li&gt;
&lt;li&gt;CreateHostingEnvironment();-&amp;gt; HostingEnvironment环境相关配置&lt;/li&gt;
&lt;li&gt;CreateHostBuilderContext();-&amp;gt; HostBuilder 上下文构建，这个略复杂&lt;/li&gt;
&lt;li&gt;BuildAppConfiguration();-&amp;gt;围绕ConfigureAppConfiguration的一系列回调-&amp;gt;执行ConfigureAppConfiguration；&lt;/li&gt;
&lt;li&gt;CreateServiceProvider();&amp;gt;服务注册添加，并执行ConfigureServices添加的一系列回调-&amp;gt;执行ConfigureServices；&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;aspnetcore 应用程序，是一个拥有内置的Self-hosted的WebServer,用于处理外部请求。大部分情况下以控制台应用的方式实现子托管（Self-Hosted）。
相对于传统的aspnet 提供的大而全的设计，aspnetcore以最小化抽象设计为原则，以扩展(中间件)方式提供的易用性扩展来实现更高程度的按需使用。
在ASP.NET Core应用中通过配置并启动一个Host来完成应用程序的启动和其生命周期的管理。而Host的主要的职责就是Web Server的配置和Pilpeline（请求处理管道）的构建。
在应用中主要通过 构造一个IHostBuilder 的抽象对象来负责(通过build()方法)创建一个Ihost实例。并最终通过Ihost下的run()方法来启动这个实例。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</id>
		<title>使用mailkit 和mimekit来发送邮件</title>
		<link href="http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email" />
		<updated>2019-10-24T00:00:00Z</updated>
		<content>&lt;h2 id="mailkitmimekit"&gt;&lt;a href="https://github.com/jstedfast/MailKit"&gt;mailkit&lt;/a&gt;和&lt;a href="https://github.com/jstedfast/MimeKit"&gt;mimekit&lt;/a&gt; 是什么&lt;/h2&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mailkit"&gt;What is MailKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mimekit"&gt;What is MimeKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by &lt;a href="https://github.com/jstedfast/MimeKit/blob/master/RFCs.md"&gt;numerous IETF specifications&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;怎么用&lt;/h2&gt;
&lt;p&gt;分为发信和收信功能&lt;/p&gt;
&lt;h3 id="section-1"&gt;发信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; 
	var message = new MimeMessage ();
	message.From.Add (new MailboxAddress (&amp;quot;Joey Tribbiani&amp;quot;, &amp;quot;joey&amp;#64;friends.com&amp;quot;));
	message.To.Add (new MailboxAddress (&amp;quot;Mrs. Chanandler Bong&amp;quot;, &amp;quot;chandler&amp;#64;friends.com&amp;quot;));
	message.Subject = &amp;quot;How you doin'?&amp;quot;;
    message.Body = new TextPart (&amp;quot;plain&amp;quot;) {
				Text = &amp;#64;&amp;quot;Hey Chandler,
I just wanted to let you know that
Monica and I were going to go play some paintball, you in?
-- Joey&amp;quot;
			};

	using (var client = new SmtpClient ()) {
		// For demo-purposes, 
        //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;smtp.friends.com&amp;quot;, 587, false);

		// Note: only needed if the SMTP server requires authentication
		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		client.Send (message);
		client.Disconnect (true);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-2"&gt;收信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using (var client = new Pop3Client ()) {
	// For demo-purposes, 
    //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;pop.friends.com&amp;quot;, 110, false);

		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		for (int i = 0; i &amp;lt; client.Count; i++) {
			var message = client.GetMessage (i);
			   Console.WriteLine (&amp;quot;Subject: {0}&amp;quot;, message.Subject);
			}
           client.Disconnect (true);
			}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;常见邮件服务提供商及端口&lt;/h2&gt;
&lt;p&gt;【sina.com】
POP3服务器地址:pop3.sina.com.cn（端口：110）
SMTP服务器地址:smtp.sina.com.cn（端口：25）&lt;/p&gt;
&lt;p&gt;【sinaVIP】&lt;/p&gt;
&lt;p&gt;POP3服务器:pop3.vip.sina.com （端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器:smtp.vip.sina.com （端口：25）&lt;/p&gt;
&lt;p&gt;【sohu.com】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop3.sohu.com（端口：110）
SMTP服务器地址:smtp.sohu.com（端口：25）&lt;/p&gt;
&lt;p&gt;【126邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop.126.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址:smtp.126.com（端口：25）&lt;/p&gt;
&lt;p&gt;【139邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：POP.139.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：SMTP.139.com(端口：25)&lt;/p&gt;
&lt;p&gt;【163.com】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop.163.com（端口：110）
SMTP服务器地址:smtp.163.com（端口：25）&lt;/p&gt;
&lt;p&gt;【QQ邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：pop.qq.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：smtp.qq.com（端口：25）&lt;/p&gt;
&lt;p&gt;【QQ企业邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：pop.exmail.qq.com （SSL启用 端口：995）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：smtp.exmail.qq.com（SSL启用 端口：587/465）&lt;/p&gt;
&lt;p&gt;【yahoo.com】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop.mail.yahoo.com（端口：995）
SMTP服务器地址:smtp.mail.yahoo.com（端口：587)&lt;/p&gt;
&lt;p&gt;【HotMail】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：pop3.live.com（端口：995）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：smtp.live.com（端口：587）&lt;/p&gt;
&lt;p&gt;【Gmail】
POP3服务器地址:pop.gmail.com（SSL启用端口：995）
SMTP服务器地址:smtp.gmail.com（SSL启用 端口：587）&lt;/p&gt;
&lt;p&gt;【263.net】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop3.263.net（端口：110）
SMTP服务器地址:smtp.263.net（端口：25）&lt;/p&gt;
&lt;p&gt;【Foxmail】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:POP.foxmail.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址:SMTP.foxmail.com（端口：25）&lt;/p&gt;
</content>
		<summary>&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2019/05/2019-06-05-why-redis</id>
		<title>redis十问</title>
		<link href="http://blog.robinjiang.com/posts/2019/05/2019-06-05-why-redis" />
		<updated>2019-05-06T00:00:00Z</updated>
		<content>&lt;h3 id="redis"&gt;1. Redis为什么这么快&lt;/h3&gt;
&lt;p&gt;1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；&lt;/p&gt;
&lt;p&gt;2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；&lt;/p&gt;
&lt;p&gt;3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；&lt;/p&gt;
&lt;p&gt;4、使用多路I/O复用模型，非阻塞IO；&lt;/p&gt;
&lt;p&gt;5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；&lt;/p&gt;
&lt;p&gt;以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：&lt;/p&gt;
&lt;h3 id="io"&gt;多路 I/O 复用模型&lt;/h3&gt;
&lt;p&gt;多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。&lt;/p&gt;
&lt;p&gt;**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。&lt;/p&gt;
&lt;h3 id="redis-1"&gt;2.那么为什么Redis是单线程的&lt;/h3&gt;
&lt;p&gt;因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）&lt;/p&gt;
</content>
		<summary>&lt;p&gt;1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2018/12/2018-12-20-how-to-logging-in-production-enviroment</id>
		<title>生成环境的若干日志实践</title>
		<link href="http://blog.robinjiang.com/posts/2018/12/2018-12-20-how-to-logging-in-production-enviroment" />
		<updated>2018-12-20T00:00:00Z</updated>
		<content>&lt;ul&gt;
&lt;li&gt;只记录你需要的日志数据；&lt;/li&gt;
&lt;li&gt;关于日志数据数据中的敏感信息记录问题，账户名可以保留，但银行卡/密码等敏感信息，必须要在源头过滤掉，严禁在日志生成后使用文本处理的方式处理这些字段。&lt;strong&gt;推荐的方式是使用日志模板+关键字过滤的方式来在开发阶段就将这些不规范的日志暴露出来&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;生产环境的日志应该需要包含你的业务细节，而不是流水线日志。如果你的开发框架支持AOP拦截日志的话，先确定你知道如何在生产环境中关闭这些日志，大部分情况下，AOP日志有且仅用于开发环境的debug，生产环境如果用这种方式记录日志的话，那么大部分业务日志都会被这类日志冲垮；&lt;/li&gt;
&lt;li&gt;除了常见的日志级别外，日志系统需要支持简单模式和完整模式的日志；&lt;/li&gt;
&lt;li&gt;日志要尽可能做到不干扰业务正常允许，但允许例外，特定情况下，日志可能是你最后的灾备恢复手段。&lt;/li&gt;
&lt;li&gt;记录日志是一个高IO的操作，条件允许的情况下，不要干扰主业务的io操作。&lt;/li&gt;
&lt;li&gt;善用日志模板，提高日志可读性以及降低日志大小&lt;/li&gt;
&lt;/ul&gt;
</content>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</id>
		<title>《如何阅读一本书》读书笔记:关于计算机应用类书籍的阅读-2018年版</title>
		<link href="http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book" />
		<updated>2018-08-16T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;关于实用性书籍&lt;/h2&gt;
&lt;p&gt;大部分计算机类，除了纯理论书籍外，基本都可以划分到实用性书籍中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在阅读实用性书籍时，先要了解一件事：任何实用性的书籍都不能解决该书所关心的实际问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实用性的书籍主要是针对实际的问题给出解决方式的建议。而实际的问题是需要行动才能够解决的。行动只能在现实发生，不能够在书中发生。每一个问题都有其独特的时间，地点，和特殊的环境。实用性的书籍很难提供完完全全贴合每一个特殊问题的解决方式，它能够提供的是运用在同类型特殊状况中的规则。而问题实际的解决需要读者对规则进行特殊情况的想象，才能在实际状况中进行运用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.实用性书籍分为两种类型：说明规则和说明规则形成的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明规则的实用性书籍，作为读者要寻找的主旨，主要是规则。它一般是在建议某件事情值得做，并且一定会有所收获。比如每天冥想半小时，胜过睡眠10小时。这种类型的书也可能配合规则的原理或者实例来增加叙述内容的可信度。&lt;/p&gt;
&lt;p&gt;说明规则形成原理的书，许多伟大的经济、政治、道德巨著就属于这一类。主旨是在说明某件事情的状态。虽然这类使用性的书籍和纯理论书籍看起来很相似，但是它的核心依然是行动的问题。人们在什么样的情况下能够做得更好或者更糟糕的问题。所以好的读者在阅读这类书籍的时候，会在原理之上，找出实际运用规则的方法。&lt;/p&gt;
&lt;p&gt;而在评价一本实用性的书籍的时候，所有的事情都与结果和目标有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.阅读实用性书籍需要询问的4个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）这本书是在谈论什么？&lt;/p&gt;
&lt;p&gt;（2）作者的主旨和论述是什么？&lt;/p&gt;
&lt;p&gt;（3）内容是真实的吗？&lt;/p&gt;
&lt;p&gt;（4）这本书与我有什么关系？&lt;/p&gt;
&lt;p&gt;当阅读完一般实用性书籍，读者最后觉得作者所说确实有价值，TA会按照作者的建议去行动。如果没有，那表示读者并没有完全的赞同作者提出的规则。&lt;/p&gt;
&lt;h2 id="section-1"&gt;针对计算机专业的书籍有什么特殊&lt;/h2&gt;
&lt;p&gt;上述四个问题基本能解决流程性的问题，但是不能解决实战的问题，目前我也在探索如何高效的吸收一本技术书籍的内容。&lt;/p&gt;
&lt;p&gt;以下是常见的一些问题以及克服办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术类图书的选择，假定同一本书有多个版本，一般情况下选新版的，理论上新版本会追踪该系列的技术堆栈的最新情况，或者说比较接近当前堆栈的最新情况&lt;/li&gt;
&lt;li&gt;相对其他学科，计算机专业的经典图书很少，而且这几年尤其是08年以后，占坑的书目很多，举个例子，之前xxx in Action系列都是不错的好书，后面就烂了招牌。选书之前一定要看样章，但不建议看书评，之前喜欢在知乎和公众号看书评，看完之后毁了不少好书，这些加工过的观点很容易毁掉一本好书&lt;/li&gt;
&lt;li&gt;绝大部分书不如官方文档详尽，嗯，之前手贱买过一本aspnet mvc5的书，作者把几篇blog+官方源码贴出来就发表了，然后全网灌水，从此这个系列一生黑&lt;/li&gt;
&lt;li&gt;关于贴代码的书，代码超过三成以上的书，都不建议购买，纯粹是骗钱的&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2017/08/2017-08-11-gitlab-ci-powershell-bugs</id>
		<title>gitlab ci与Powershell 乱码</title>
		<link href="http://blog.robinjiang.com/posts/2017/08/2017-08-11-gitlab-ci-powershell-bugs" />
		<updated>2017-08-11T00:00:00Z</updated>
		<content>&lt;p&gt;存在多种情况下的乱码，应用级别的乱码和控制台乱码
应用级别的乱码类似如下：&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;error MSB1009: ��Ŀ�ļ������ڡ�&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这类需要配置应用的中文输出&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;修改cmd的代码页即可。
一种方法是在cmd的属性中修改默认代码页为437，第二种是用chcp 437命令修改。
不过这两种解决方法的副作用是msbuild的输出会变为英文。
更好的解决方法暂时还没倒腾出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二种，控制台乱码，这个难治，而且原因千奇百怪&lt;/p&gt;
&lt;p&gt;参考方案如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/weixin_43426860/article/details/83348284"&gt;解决windowspowershell中文显示问号及乱码问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cnblogs.com/weihanli/p/fix-Chinese-characters-display-abnormal.html"&gt;Windows 10 powershell 中文乱码解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果以上两种方案都不适用与你的化，那么放大招了，gitlab-ci的宿主系统切换成windows server2016, 实测有效&lt;/p&gt;
</content>
		<summary>&lt;p&gt;存在多种情况下的乱码，应用级别的乱码和控制台乱码
应用级别的乱码类似如下：&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</id>
		<title>GELF日志格式漫谈</title>
		<link href="http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf" />
		<updated>2017-06-12T00:00:00Z</updated>
		<content>&lt;h2 id="gelf"&gt;什么是GELF&lt;/h2&gt;
&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="structured-events-from-anywhere.compressed-and-chunked"&gt;Structured events from anywhere. Compressed and chunked.&lt;/h2&gt;
&lt;p&gt;The Graylog Extended Log Format (GELF) is a log format that avoids the shortcomings of classic plain syslog:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Limited to length of 1024 bytes – Not much space for payloads like backtraces&lt;/li&gt;
&lt;li&gt;No data types in structured syslog. You don’t know what is a number and what is a string.&lt;/li&gt;
&lt;li&gt;The RFCs are strict enough but there are so many syslog dialects out there that you cannot possibly parse all of them.&lt;/li&gt;
&lt;li&gt;No compression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://docs.graylog.org/en/2.4/pages/gelf.html#gelf-payload-specification"&gt;GELF 规范&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;A GELF message is a JSON string with the following fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GELF spec version – “1.1”; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;host&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the name of the host, source or application that sent this message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;short_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a short descriptive message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;full_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a long message that can i.e. contain a backtrace; optional.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Seconds since UNIX epoch with optional decimal places for milliseconds; &lt;em&gt;SHOULD&lt;/em&gt; be set by client library. Will be set to the current timestamp (now) by the server if absent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the level equal to the standard syslog levels; optional, default is 1 (ALERT).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;facility&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;line&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the line in a file that caused the error (decimal); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;file&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the file (with path if you want) that caused the error (string); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_[additional field]&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;every field you send and prefix with an underscore (&lt;code&gt;_&lt;/code&gt;) will be treated as an additional field. Allowed characters in field names are any word character (letter, number, underscore), dashes and dots. The verifying regular expression is: &lt;code&gt;^[\w\.\-]*$&lt;/code&gt;. Libraries SHOULD not allow to send id as additional field (&lt;code&gt;_id&lt;/code&gt;). Graylog server nodes omit this field automatically。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="gelf-1"&gt;GELF 能解决什么问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这是个格式规范，能够让绝大部分日志格式相对统一合理，提高日志可读性。&lt;/li&gt;
&lt;li&gt;这是个json规范，实现比较简单。&lt;/li&gt;
&lt;li&gt;由于无视源文本类型，对于绝大部分日志工具类能很好支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelf-2"&gt;实践中，GELF 存在哪些问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是一个非强制性约束，也就意味着，你需要根据现有业务增加更多的约束条件，比如异常堆栈等标准信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连续日志的追踪需要增加更高级别的支持，类似CorrelationID；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于敏感信息过滤问题，假设要实现用户密码字段的过滤，只能通过正则处理生成后的日志文本来过滤，无法前置过滤；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p timestamp="" controllername="" toekn="" postdata=""&gt;日志模板问题，大部分日志是依据格式化的模板生成的，类似“-:-”；日志模板能够极大的降低传输的数据量，很遗憾，这套规范中很难去扩展实现这种模板支持；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Serilog这类提供更多日志信息的库，容易丢失支持的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelfserilogtemplate"&gt;GELF+Serilog+template实践&lt;/h2&gt;
&lt;p&gt;repo近期会迁入github&lt;/p&gt;
</content>
		<summary>&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2017/05/2017-05-10-about-liblog</id>
		<title>抽象日志组件</title>
		<link href="http://blog.robinjiang.com/posts/2017/05/2017-05-10-about-liblog" />
		<updated>2017-05-10T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;本篇是基于&lt;a href="https://github.com/damianh/LibLog"&gt;Liblog&lt;/a&gt; 的结构分析，同时我提倡在非netcore项目中使用此类库，正常情况下只需要在基础组件库中生成单个文件即可，同时一次安装，终身有效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志核心功能以接口的方式进行定义，简单有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; interface ILog{
    bool Log(LogLevel logLevel, Func&amp;lt;string&amp;gt; messageFunc, Exception exception = null,
            params object[] formatParameters);
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Liblog的核心是使用提供者模式(Provider Pattern)来实现对各种具体日志实现支持的。调用方面通过 LogProvider.GetCurrentClassLogger() 或者 LogProvider.For() 来获取Ilog的实例。其中GetCurrentClassLogger() 适用与所有静态类或者扩展方法，For()主要用于可实例化的内部。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static readonly ILog logger = LogProvider.GetCurrentClassLogger()
 
private static readonly ILog Logger = LogProvider.For()
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h3 id="section"&gt;两个小问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;日志缓存策略，即生成的日志在本地存在buffer中，后续一次性提交，或者出现了整个日志内容过大，导致无法一次性提交的情况；那么Logproverider.For() 获取的日志实例会出现无法释放的问题，最后只能通过强制GC来释放。解决方案，尽可能控制你的日志文本大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LogProvider.GetCurrentClassLogger()并非是一个线程安全方法，如果需要在Parallel和Task中使用的话，一定要在外部获取实例后传递进去；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于多线程下的日志实践，这个问题比较头大，会单独开一章来描述我的方案&lt;/p&gt;
&lt;/blockquote&gt;
</content>
		<summary>&lt;p&gt;本篇是基于&lt;a href="https://github.com/damianh/LibLog"&gt;Liblog&lt;/a&gt; 的结构分析，同时我提倡在非netcore项目中使用此类库，正常情况下只需要在基础组件库中生成单个文件即可，同时一次安装，终身有效。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</id>
		<title>关于Metrics，Tracing和Logging</title>
		<link href="http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging" />
		<updated>2017-04-12T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;这是一篇翻译文章&lt;/p&gt;
&lt;p&gt;Peter Bourgon 原作： &lt;a href="http://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html"&gt;Metrics, tracing, and logging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，我很荣幸的参加了 2017 分布式追踪峰会(2017 Distributed Tracing Summit)， 并和来自 AWS/X-Ray,
OpenZipkin, OpenTracing, Instana, Datadog, Librato，以及其他更多组织的同仁进行了愉快的沟通和讨论。
其中一个重要的论点，是针对监控项目的范围和定义的。作为一个分布式追踪系统，应该管理日志么?从不同角度看来，到底什么是日志?如何通过一张图形象的定位这些形形色色的系统?&lt;/p&gt;
&lt;p&gt;总体说来，我觉得我们是在一些通用的名词间纠结。我想我们可以通过图表来定义监控的作用域，使各名词的作用范围更明确。 我们使用维恩图(Venn diagram)来描述 Metrics, Tracing, Logging 三个概念的定义。他们三者在某些情况下是重叠的，但是我尽量尝试定义他们的不同。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/01.png" class="img-fluid" alt="Annotated Venn diagram" /&gt;&lt;/p&gt;
&lt;p&gt;Metrics 的特点是，它是可累加的， 他们具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计; 输入 HTTP 请求的数量可以被定义为一个计数器，用于简单累加;请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Logging 的特点是，它描述一些离散的(不连续的)事件。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：应用通过一个滚动的文件输出 Debug 或 Error 信息，并通过日志收集系统，存储到 Elasticsearch 中;
审批明细信息通过 Kafka，存储到数据库(BigTable)中;
又或者，特定请求的元数据信息，从服务请求中剥离出来，发送给一个异常收集服务，如 NewRelic。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tracing 的最大特点就是，它在单次请求的范围内，处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：一次调用远程服务的 RPC 执行过程;一次实际的 SQL 查询语句;一次 HTTP 请求的业务性 ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上述的定义，我们可以标记上图的重叠部分。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/02.png" class="img-fluid" alt="修正的带注释的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;当然，大量的被监控的应用是具有分布式能力(Cloud-native)的应用，逻辑处理在单次请求的范围内完成。因此，讨论追踪的上下文是有意义的。但是，我们注意到，并不是所有的监控系统都绑定在请求的生命周期上的。他们可能是逻辑组件诊断信息、处理过程的生命周期明细信息，这些信息和任何离散的请求时正交关系。&lt;/p&gt;
&lt;p&gt;所以，不是所有的 Metrics 和 Log 都可以被塞进追踪系统的概念中，至少在不经过数据加工处理是不行的。又或者，我们可能发觉使用 Metrics 统计数据，对应用监控有很大帮助，例如 Prometheus 生态，可以量化的实时展现应用视图;相应的，如果我们将 Metrics 统计数据强行使用针对 Log 的管道来处理，将使我们丢失很多特性。&lt;/p&gt;
&lt;p&gt;那么，在这里，我们可以开始对已知的系统进行分类。如：Prometheus，专一的 Metrics 统计系统，随着时间推移，也许会进化为追踪系统，进而进行请求内的指标统计，但不太可能深入到 Log 处理领域。ELK 生态提供 Log 的记录，滚动和聚合，并在其他领域不停的积累更多的特性，并集成进来。&lt;/p&gt;
&lt;p&gt;另外，我发现通过维恩图的方式展现三者关系时，会正巧展现出一个附加效应。在这三个功能域中，Metrics 倾向于更节省资源，因为他会“天然的”压缩数据。相反，日志倾向于无限增加的，会频繁的超出预期的容量。(有另一篇我写的关于这方面的文章，查看，译者注：未翻译)。所以，我们可以在图上，绘制出容量的需求趋势，Metrics 低到 Logging 高，
而 Trace 可能处于他们两的中间位置&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/03.png" class="img-fluid" alt="带有梯度的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;也许，这不是最完美的方式描述这三者的管理，但我从会议现场收到的反馈来看，这个分类还是相当不错的：随着三者的关系越清晰，我们越容易建设性的讨论其他问题。如果你尝试对产品的功能进行定位，你可能也需要这张图。&lt;/p&gt;
</content>
		<summary>&lt;p&gt;这是一篇翻译文章&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</id>
		<title>《如何阅读一本书》读书笔记：关于碎片化阅读与主题阅读 -2017年版</title>
		<link href="http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book" />
		<updated>2017-02-21T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经典值得回味，再过去的一年中，各种读书plan终究敌不过职场压力以及自己的惰性，趁着年假，抽了一天时间重新审阅了这本经典。&lt;/p&gt;
&lt;h2 id="section"&gt;关于碎片化阅读&lt;/h2&gt;
&lt;p&gt;在过去的很长一段时间内，碎片化阅读基本成了我主要的阅读途径，刷微博也好，刷公众号也好，总觉得自己花上三五分钟看完各种总结，技巧，自己就能吸收并为己所用。然并卵，大部分时间花出去之后未获得成效不提，更多的是增加自己的认知焦虑。而解决这种焦虑的根本途径是主题阅读。&lt;/p&gt;
&lt;h2 id="section-1"&gt;关于主题阅读&lt;/h2&gt;
&lt;p&gt;主题阅读分为两个阶段，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主题阅读的准备阶段，这个阶段需要根据你的主题选择合适的书目，在这里你也需要用上检视阅读的技巧；&lt;/li&gt;
&lt;li&gt;阅读阶段，共分为五个步骤，每个步骤都有我们需要学习和改进的地方。&lt;/li&gt;
&lt;li&gt;如何运用主题工具书，这本工具书能够在三方面提供帮助，并且能从三个不同的方向指导关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-2"&gt;准备阶段&lt;/h3&gt;
&lt;p&gt;在这个阶段最重要的就是选书以及对于所选的书有一定的了解。首先在选书阶段，我们可以通过参考图书馆的目录、网络收集、读过的书中的书目索引等途径建立一个自己的书目。其次我们可以通过检视阅读的方式来进行进一步筛选，你要检视你书单上所有的书，合理简化书单并且对自己想要研究的主题有一个清晰的概念，为接下来的阅读阶段做准备。&lt;/p&gt;
&lt;h3 id="section-3"&gt;阅读阶段的五个步骤&lt;/h3&gt;
&lt;p&gt;现在你已经检视了相当多的书,并且对你要研究什么主题了如指掌。接下来就可以正式进入主题阅读的步骤了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;步骤一是找到相关的章节。&lt;/strong&gt; 你首先应该把你选中的每一本书都检视阅读一遍，找出书中与主题相关的章节，我们要抓住一个重点，主题阅读时主题才是我们关心的，而不是书籍本身。&lt;/li&gt;
&lt;li&gt;**步骤二是带引作者与你达成共识。**首先你要建立你的观点，在书中寻找和你观点一致的论据，但是我们要做好心理准备，可能很多作者书中的观点对我们来说都是无用的。&lt;/li&gt;
&lt;li&gt;**步骤三是厘清问题。**我们应该根据主题建立主旨，按照一定的秩序将问题罗列出来，这个秩序要和主题有关，第一个问题和我们研究的现象的特质有关；第二个问题是这个现象如何被发现，最后一个问题是这个现象产生了什么影响。&lt;/li&gt;
&lt;li&gt;**第四个步骤界定议题。**对于一个问题我们在不同的作者口中能够得出多种答案，这时候需要找出不同意见之间的关联，并且根据作者的观点来分类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第五个步骤分析讨论&lt;/strong&gt;。 在最后这个步骤，我们还是要依照特定的顺序来提问题，辨认为什么是这个顺序，我们要说明这些问题的不同答案，并且说明原因。我们也一定要能够从我们检视的书中找出支持我们把答案如此分类的依据，只有做到这些，才算是对我们的问题做了讨论分析，真正了解了问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;如何应用主题工具书&lt;/h2&gt;
&lt;p&gt;主题工具书是为了解决选书的问题。它能告诉你在广泛的材料中到哪里找和主题相关的章节，这能够帮你节省时间。**这本工具书可以从三方面帮助你：即启动阅读，建议阅读和指导阅读。**启动阅读指的是主题工具书能够帮助我们在阅读经典名著时先阅读来自大量不同作者的比较短的章节，避免我们阅读名著的畏难心理；建议阅读指的是在使用工具书进行主题阅读时，还可能激发出对别的主题的兴趣；指导阅读是说主题阅读加上主题工具书，可以帮助读者在某个章节中找出和主题真正相关的地方，强化读者对章节的诠释能力，帮助读者发现某个章节在不同主题中的丰富意义。&lt;/p&gt;
</content>
		<summary>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2016/08/2019-08-06-redis-distributed-lock</id>
		<title>关于redis分布式锁入门</title>
		<link href="http://blog.robinjiang.com/posts/2016/08/2019-08-06-redis-distributed-lock" />
		<updated>2016-08-06T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;原理&lt;/h1&gt;
&lt;p&gt;单一实例下：使用setnx命令(在key不存在时,创建并设置value 返回1,key存在时,会返回0)来获取锁。&lt;/p&gt;
&lt;h1 id="section-1"&gt;应用&lt;/h1&gt;
&lt;p&gt;以扣库存为例，使用锁能够有效保证不会被超卖；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基础版方案：数据库锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT stock from goods where ID =1 for update;
update  goods set stock=stock-1 where id=1 and stock=10
// 正常情况下看你业务需求，如果能够在落库前确认库存的话，上面这句话后面的stock=10能够限定库存锁定值
// 如果不使用这个stock=10的话，会有一定的副作用，比如说常见的，多线程轮扣
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h2 id="redis-v0"&gt;redis 版v0&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​     使用setnx写入一个键值，如果成功则表明获取到锁，执行业务;对于没有获取到锁的，则会轮询获取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            int waitIntervalMs = 50;//间隔等待时长 毫秒
            string lockKey = &amp;quot;lock_key:&amp;quot; + key; 
            DateTime begin = DateTime.Now;
            while (true)
            {
                if (redisClient.SetNX(lockKey, new byte[] { 1 }) == 1)
                {
                    redisClient.Expire(lockKey, expirySeconds);
                    return true;
                } 
                //不等待锁则返回
                if (waitSeconds &amp;lt;= 0)
                    break;

                if ((DateTime.Now - begin).TotalSeconds &amp;gt;= waitSeconds)//等待超时
                    break;

                System.Threading.Thread.Sleep(waitIntervalMs);
            }
            return false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不管是该业务成功、失败或者异常，需要确保该锁在周期结束后能被释放&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redis 版v1&lt;/p&gt;
&lt;p&gt;V0版本存在的缺陷：比较致命的是可能会出现，任务还未完成，锁就超时了，导致key被回收了，那么能不能将锁的申请时间作为值进行存储呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;​```
int waitIntervalMs = 200;//间隔等待时长 毫秒 设置成足够长，至少要超过数据库的超时响应时间
string lockKey = &amp;quot;lock_key:&amp;quot; + key; 
DateTime begin = DateTime.Now;
DateTime now = DateTime.Now;
while (true)
            {
              //在key值存在的情况下
               if(redisclient.ExistKey(lockKey))
               {
               //如果key对应的value值+超时时间后小于当前时间，则移除key值，让业务正常运行
               if(Convert.ToDateTime(redisclient.GetKey(lockkey).Value)+TimeLimit&amp;lt;now){
               redisclient.remove(lockkey);
               }
               }
                if (redisClient.SetNX(lockKey, now.tostring()) == 1)
                {
                    redisClient.Expire(lockKey, expirySeconds);
                    return true;
                } 
                //不等待锁则返回
                if (waitSeconds &amp;lt;= 0)
                    break;

                if ((DateTime.Now - begin).TotalSeconds &amp;gt;= waitSeconds)//等待超时
                    break;

                System.Threading.Thread.Sleep(waitIntervalMs);


            }
            return false; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-2"&gt;遗留的问题&lt;/h1&gt;
&lt;p&gt;在单个redis实例下，上述代码工作都ok，如果存在redis集群，且master挂掉的情况，那么这个锁一定锁不住&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;单一实例下：使用setnx命令(在key不存在时,创建并设置value 返回1,key存在时,会返回0)来获取锁。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</id>
		<title>《如何阅读一本书》读书笔记-2016年版</title>
		<link href="http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book" />
		<updated>2016-03-15T00:00:00Z</updated>
		<content>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;为什么读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;提高阅读效率&lt;/li&gt;
&lt;li&gt;从更高的层次审阅自己的阅读方式，以期获得更具实用性的阅读技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;读了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;阅读的四个层次：基础阅读，检视阅读，分析阅读，主题阅读&lt;/li&gt;
&lt;li&gt;轻重缓急：对于不同的内容需要审时度势，以判定花费的时间和精力，并非所有的内容都需要一字一句的逐个分析&lt;/li&gt;
&lt;li&gt;大部分文本阅读无需达到分析阅读的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;理解了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果是获取技能或者认知类增长的情况下，主题阅读更有效率&lt;/li&gt;
&lt;li&gt;对于娱乐类型的阅读，建议无脑阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;如何做&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按主题的方式对过往的认知进行归类，并考虑输出成思维导图或技术图谱&lt;/li&gt;
&lt;li&gt;放弃一部分消遣式的阅读&lt;/li&gt;
&lt;li&gt;有必要审视自己的碎片化阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;综合评价&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就这本书而言，翻译有点糟心，考虑继续深读或理解的化，有必要准备英文版本的读&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2016/01/2016-01-13-about-index</id>
		<title>索引原理</title>
		<link href="http://blog.robinjiang.com/posts/2016/01/2016-01-13-about-index" />
		<updated>2016-01-13T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;简介&lt;/h1&gt;
&lt;h2 id="section-1"&gt;为什么要有索引？&lt;/h2&gt;
&lt;p&gt;对于通用系统而言，大部分数据读操作比例远高于写入操作，针对查询进行优化的时候，优先需要考虑索引优化。&lt;/p&gt;
&lt;h2 id="section-2"&gt;什么是索引？&lt;/h2&gt;
&lt;p&gt;索引在MySQL中也叫是一种“键”，是存储引擎用于快速找到记录的一种&lt;strong&gt;数据结构&lt;/strong&gt;。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。
索引优化应该是对查询性能优化最有效的手段了。&lt;/p&gt;
&lt;h2 id="section-3"&gt;常见误区&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;索引是不是越多越好？X&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;ul&gt;
&lt;li&gt;索引会增加数据库服务器写入操作的成本（INNODB对这个 做了一个优化：插入缓存 将多次插入合并成一次插入）&lt;/li&gt;
&lt;li&gt;太多的索引会影响mysql查询优化器的选择时间（影响查询效率）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;索引的过度设计问题&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;ul&gt;
&lt;li&gt;索引应该属于专事专办，大部分情况下是&amp;quot;&lt;strong&gt;私人定制&lt;/strong&gt;&amp;quot;款，针对特定sql的索引优化未必适用于其他sql，针对特定业务的索引优化未必适合其他业务；&lt;/li&gt;
&lt;li&gt;** 索引不是万能的，使用索引的初衷是解决查询问题，如果存在其他方案解决的话，应该优先考虑方案的可用性，而不是一定要把问题限制在db内解决**&lt;/li&gt;
&lt;li&gt;索引的适用性问题，blob,img,text这些数据类型不适合用来做索引；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id="section-4"&gt;索引原理&lt;/h1&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;索引是一种利用某种规则的数据结构与实际数据的关系加快数据查找的功能；
索引数据节点中有着实际文件的位置，因为索引是根据特定的规则和算法构建的,在查找的时候遵循索引的规则可以快速查找到对应数据的节点，从而达到快速查找数据的效果；其实宏观来说索引其实是一种概念而不是具体的某项技术，只是我们在某个技术中运用得比较广泛和鲜明（比如说数据库）渐渐的有了特定领域的标签，其实在生活中索引的使用无处不在，比如说：书本里的目录；读书时的座位号，考试编号都有类似索引的功能;
总结来所有通过某规则数据结构和实际目标关联，根据特定规则算法快速寻址的功能都可以称之为索引；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;索引通过特定的数据结构来实现快速数据查找。&lt;/p&gt;
&lt;h2 id="section-5"&gt;索引的数据结构&lt;/h2&gt;
&lt;h3 id="btree"&gt;BTree&lt;/h3&gt;
&lt;p&gt;可以被用在=,&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree&lt;/li&gt;
&lt;li&gt;B+Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hash"&gt;Hash&lt;/h3&gt;
&lt;p&gt;Hash索引只能用于对等比较，例如=,&amp;lt;=&amp;gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。&lt;/p&gt;
&lt;h4 id="section-6"&gt;弊端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引仅仅能满足“=”,“IN”,“&amp;lt;=&amp;gt;”查询，不能使用范围查询。&lt;/li&gt;
&lt;li&gt;联合索引中，Hash索引不能利用部分索引键查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引无法避免数据的排序操作&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引任何时候都不能避免表扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="hash-1"&gt;关于hash索引&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;hash索引查找数据基本上能一次定位数据，当然有大量碰撞的话性能也会下降。而btree索引就得在节点上挨着查找了，很明显在数据精确查找方面hash索引的效率是要高于btree的；&lt;/li&gt;
&lt;li&gt;那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；&lt;/li&gt;
&lt;li&gt;对于btree支持的联合索引的最优前缀，hash也是无法支持的，联合索引中的字段要么全用要么全不用。&lt;/li&gt;
&lt;li&gt;hash不支持索引排序，索引值和计算出来的hash值大小并不一定一致。&lt;/li&gt;
&lt;/ol&gt;
</content>
		<summary>&lt;p&gt;对于通用系统而言，大部分数据读操作比例远高于写入操作，针对查询进行优化的时候，优先需要考虑索引优化。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2016/01/2019-11-15-mysql-lock</id>
		<title>MySQL中select * for update锁表的范围</title>
		<link href="http://blog.robinjiang.com/posts/2016/01/2019-11-15-mysql-lock" />
		<updated>2016-01-13T00:00:00Z</updated>
		<content>&lt;p&gt;由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table&lt;/p&gt;
&lt;p&gt;Lock (将整个资料表单给锁住)。 举个例子: 假设有个表单products ，里面有id跟name二个栏位，id是主键。&lt;/p&gt;
&lt;p&gt;例1: (明确指定主键，并且有此笔资料，row lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id='3' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例2: (明确指定主键，若查无此笔资料，无lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id='-1' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例2: (无主键，table lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE name='Mouse' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例3: (主键不明确，table lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id&amp;lt;&amp;gt;'3' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例4: (主键不明确，table lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;
注1: &lt;strong&gt;FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注2: &lt;strong&gt;要测试锁定的状况，可以利用MySQL的Command Mode ，开两个个视窗来做测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注3：Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改修改、删除） 。是表级锁时，不管是否查询到记录，都会锁定表。&lt;/p&gt;
</content>
		<summary>&lt;p&gt;由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.robinjiang.com/posts/2016/01/2016-01-15-mysql-index</id>
		<title>MySQL索引原理</title>
		<link href="http://blog.robinjiang.com/posts/2016/01/2016-01-15-mysql-index" />
		<updated>2016-01-13T00:00:00Z</updated>
		<content>&lt;ul&gt;
&lt;li&gt;基本概念
&lt;ul&gt;
&lt;li&gt;索引的功能就是加速查找&lt;/li&gt;
&lt;li&gt;mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常用索引
&lt;ul&gt;
&lt;li&gt;普通索引INDEX：加速查找&lt;/li&gt;
&lt;li&gt;唯一索引：
&lt;ul&gt;
&lt;li&gt;主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）&lt;/li&gt;
&lt;li&gt;唯一索引UNIQUE:加速查找+约束（不能重复）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;联合索引：
&lt;ul&gt;
&lt;li&gt;PRIMARY KEY(id,name):联合主键索引&lt;/li&gt;
&lt;li&gt;UNIQUE(id,name):联合唯一索引&lt;/li&gt;
&lt;li&gt;INDEX(id,name):联合普通索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引的两大类型hash与btree
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们可以在创建上述索引的时候，为其指定索引类型，分两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hash类型的索引：查询单条快，范围查询慢&lt;/li&gt;
&lt;li&gt;btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不同的存储引擎支持的索引类型也不一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；&lt;/li&gt;
&lt;li&gt;MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；&lt;/li&gt;
&lt;li&gt;Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；&lt;/li&gt;
&lt;li&gt;NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；&lt;/li&gt;
&lt;li&gt;Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;我们可以在创建上述索引的时候，为其指定索引类型，分两类：&lt;/p&gt;</summary>
	</entry>
</feed>