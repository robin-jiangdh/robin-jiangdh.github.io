<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-12-17T22:54:23.2331576"><meta name="build-number" content="${buildNumber}">       <title>ASP.NET CORE 管道模型和中间件 | blog</title><script id="virtual-toc-data" type="application/json">[{"id":"asp-net","level":0,"title":"ASP.NET 管道模型","anchor":"#asp-net"},{"id":"aspnetcore","level":0,"title":"aspnetcore下的管道模型","anchor":"#aspnetcore"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="ASP.NET CORE 管道模型和中间件 | blog"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="blog Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="/1.0/2019-12-22-aspnetcore-middleware-and-pipeline.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="ASP.NET CORE 管道模型和中间件 | blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "/1.0/2019-12-22-aspnetcore-middleware-and-pipeline.html#webpage", "url": "/1.0/2019-12-22-aspnetcore-middleware-and-pipeline.html", "name": "ASP.NET CORE 管道模型和中间件 | blog", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "blog Help" }</script><!-- End Schema.org --></head>      <body data-id="2019-12-22-aspnetcore-middleware-and-pipeline" data-main-title="ASP.NET CORE 管道模型和中间件" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="post///netcore"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>blog 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="2019-12-22-aspnetcore-middleware-and-pipeline"   id="2019-12-22-aspnetcore-middleware-and-pipeline.md">ASP.NET CORE 管道模型和中间件</h1>  <section class="chapter"><h2 id="asp-net" data-toc="asp-net"   >ASP.NET 管道模型</h2><p id="14e26f1d_57">请求进入ASP.NET 工作进程后，由进程创建HttpWorkRequest 对象，封装此次请求有关的所有信息，然后进入HttpRuntime 类进行进一步的处理。HttpRuntime 通过请求信息创建HttpContext 上下文对象，此对象将贯穿整个管道，直到响应结束。同时创建或从应用程序池里初始化一个HttpApplication对象，由此对象开始处理之前注册的多个HttpModule。之后调用HandlerFactory 创建Handler处理程序，最终处理此次请求内容，生存响应返回。 <img alt="ASP.NET 管道模型.png" src="https://blog.robinjiang.com/posts/asset/2019-12-22-aspnetcore-middleware-and-pipeline/aspnet-pipeline.jpg" class="inline-icon-" title="ASP.NET 管道模型.png"  id="14e26f1d_58"   ></p><p id="14e26f1d_59">管道架构异常复杂，同时不具备热插拔的功能。由于这套流程相对固定，对于特定的业务场景优化难度加大。</p></section><section class="chapter"><h2 id="aspnetcore" data-toc="aspnetcore"   >aspnetcore下的管道模型</h2><figure  id="14e26f1d_60"><img alt="request-pipeline" src="https://blog.robinjiang.com/posts/asset/2019-12-22-aspnetcore-middleware-and-pipeline/aspnetcore-request-pipeline.png" title="request-pipeline"   ></figure><p id="14e26f1d_61">回归web的本质，就是请求与响应而已。 中间件本质上就是一个类型为 Func&lt;RequestDelegate, RequestDelegate&gt; 的委托对象； 简单来说，中间件就是一个处理http请求和响应的组件，多个中间件构成了请求处理管道，每个中间件都可以选择处理结束，还是继续传递给管道中的下一个中间件，以此串联形成请求管道。</p><p id="14e26f1d_62">实际编码实现上，提供了一个Imiddleware的接口定义</p><div class="code-block" data-lang="none"         >
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
</div><section class="chapter"><h3 id="usemiddleware" data-toc="usemiddleware"   >UseMiddleware</h3><p id="14e26f1d_64">使用UseMiddleware扩展方法使用IMiddleware时，需要注意你的IMiddleware中间件需要注册到DI中</p></section></section><div class="last-modified"> Last modified: 17 十二月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="netcore-2019-12-21-netcore-start-process.html">AspNetCore启动流程概述</a>   <a class="navigation-links__next" href="2019-12-21-netcore-start-process.html">AspNetCore启动流程概述</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>