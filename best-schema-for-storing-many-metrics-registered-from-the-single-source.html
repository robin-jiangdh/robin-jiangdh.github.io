<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-12-17T23:19:46.9985088"><meta name="build-number" content="${buildNumber}">       <title>Best schema for storing many metrics registered from the single source | blog</title><script id="virtual-toc-data" type="application/json">[{"id":"best-schema-for-storing-many-metrics-registered-from-the-single-source-linktitle-best-schema-for-storing-many-metrics-registered-from-the-single-source-description-best-schema-for-storing-many-metrics-registered-from-the-single-source","level":0,"title":"#Best schema for storing many metrics registered from the single source\nlinkTitle: \"Best schema for storing many metrics registered from the single source\"\ndescription: \u003e\nBest schema for storing many metrics registered from the single source","anchor":"#best-schema-for-storing-many-metrics-registered-from-the-single-source-linktitle-best-schema-for-storing-many-metrics-registered-from-the-single-source-description-best-schema-for-storing-many-metrics-registered-from-the-single-source"},{"id":"1-one-row-per-metric","level":0,"title":"1 One row per metric","anchor":"#1-one-row-per-metric"},{"id":"2-each-measurement-with-lot-of-metrics-in-it-s-own-row","level":0,"title":"2 Each measurement (with lot of metrics) in it\u0027s own row","anchor":"#2-each-measurement-with-lot-of-metrics-in-it-s-own-row"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Best schema for storing many metrics registered from the single source | blog"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="blog Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="/blog/1.0/best-schema-for-storing-many-metrics-registered-from-the-single-source.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Best schema for storing many metrics registered from the single source | blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "/blog/1.0/best-schema-for-storing-many-metrics-registered-from-the-single-source.html#webpage", "url": "/blog/1.0/best-schema-for-storing-many-metrics-registered-from-the-single-source.html", "name": "Best schema for storing many metrics registered from the single source | blog", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/blog/#website", "url": "/blog/", "name": "blog Help" }</script><!-- End Schema.org --></head>      <body data-id="best-schema-for-storing-many-metrics-registered-from-the-single-source" data-main-title="Best schema for storing many metrics registered from the single source" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Clickhouse///kb-schema-design"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>blog 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="best-schema-for-storing-many-metrics-registered-from-the-single-source"   id="best-schema-for-storing-many-metrics-registered-from-the-single-source.md">Best schema for storing many metrics registered from the single source</h1>  <section class="chapter"><h2 id="best-schema-for-storing-many-metrics-registered-from-the-single-source-linktitle-best-schema-for-storing-many-metrics-registered-from-the-single-source-description-best-schema-for-storing-many-metrics-registered-from-the-single-source" data-toc="best-schema-for-storing-many-metrics-registered-from-the-single-source-linktitle-best-schema-for-storing-many-metrics-registered-from-the-single-source-description-best-schema-for-storing-many-metrics-registered-from-the-single-source"   >#Best schema for storing many metrics registered from the single source
linkTitle: &quot;Best schema for storing many metrics registered from the single source&quot;
description: &gt;
Best schema for storing many metrics registered from the single source</h2><p id="ea453a71_892">Picking the best schema for storing many metrics registered from single source is quite a common problem.</p></section><section class="chapter"><h2 id="1-one-row-per-metric" data-toc="1-one-row-per-metric"   >1 One row per metric</h2><p id="ea453a71_893">i.e.: timestamp, sourceid, metric_name, metric_value</p><p id="ea453a71_894">Pros and cons:</p><ul class="list _ul" id="ea453a71_895"><li class="list__item" id="ea453a71_896"><p>Pros: </p><ul class="list _ul" id="ea453a71_897"><li class="list__item" id="ea453a71_898"><p>simple</p></li><li class="list__item" id="ea453a71_899"><p>well normalized schema</p></li><li class="list__item" id="ea453a71_900"><p>easy to extend</p></li><li class="list__item" id="ea453a71_901"><p>that is quite typical pattern for timeseries databases</p></li></ul></li><li class="list__item" id="ea453a71_902"><p>Cons </p><ul class="list _ul" id="ea453a71_903"><li class="list__item" id="ea453a71_904"><p>different metrics values stored in same columns (worse compression)</p></li><li class="list__item" id="ea453a71_905"><p>to use values of different datatype you need to cast everything to string or introduce few columns for values of different types.</p></li><li class="list__item" id="ea453a71_906"><p>not always nice as you need to repeat all 'common' fields for each row</p></li><li class="list__item" id="ea453a71_907"><p>if you need to select all data for one time point you need to scan several ranges of data.</p></li></ul></li></ul></section><section class="chapter"><h2 id="2-each-measurement-with-lot-of-metrics-in-it-s-own-row" data-toc="2-each-measurement-with-lot-of-metrics-in-it-s-own-row"   >2 Each measurement (with lot of metrics) in it's own row</h2><p id="ea453a71_908">In that way you need to put all the metrics in one row (i.e.: timestamp, sourceid, ....) That approach is usually a source of debates about how to put all the metrics in one row.</p><section class="chapter"><h3 id="2a-every-metric-in-it-s-own-column" data-toc="2a-every-metric-in-it-s-own-column"   >2a Every metric in it's own column</h3><p id="ea453a71_909">i.e.: timestamp, sourceid, metric1_value, ... , metricN_value</p><p id="ea453a71_910">Pros and cons:</p><ul class="list _ul" id="ea453a71_911"><li class="list__item" id="ea453a71_912"><p>Pros </p><ul class="list _ul" id="ea453a71_913"><li class="list__item" id="ea453a71_914"><p>simple</p></li><li class="list__item" id="ea453a71_915"><p>really easy to access / scan for rows with particular metric</p></li><li class="list__item" id="ea453a71_916"><p>specialized and well adjusted datatypes for every metric.</p></li><li class="list__item" id="ea453a71_917"><p>good for dense recording (each time point can have almost 100% of all the possible metrics)</p></li></ul></li><li class="list__item" id="ea453a71_918"><p>Cons </p><ul class="list _ul" id="ea453a71_919"><li class="list__item" id="ea453a71_920"><p>adding new metric = changing the schema (adding new column). not suitable when set of metric changes dynamically</p></li><li class="list__item" id="ea453a71_921"><p>not applicable when there are too many metrics (when you have more than 100-200)</p></li><li class="list__item" id="ea453a71_922"><p>when each timepoint have only small subset of metrics recorded - if will create a lot of sparse filled columns.</p></li><li class="list__item" id="ea453a71_923"><p>you need to store 'lack of value' somehow (NULLs or default values)</p></li><li class="list__item" id="ea453a71_924"><p>to read full row - you need to read a lot of column files.</p></li></ul></li></ul></section><section class="chapter"><h3 id="2b-using-arrays-nested-map" data-toc="2b-using-arrays-nested-map"   >2b Using arrays / Nested / Map</h3><p id="ea453a71_925">i.e.: timestamp, sourceid, array_of_metric_names, array_of_metric_values</p><p id="ea453a71_926">Pros and cons:</p><ul class="list _ul" id="ea453a71_927"><li class="list__item" id="ea453a71_928"><p>Pros </p><ul class="list _ul" id="ea453a71_929"><li class="list__item" id="ea453a71_930"><p>easy to extend, you can have very dynamic / huge number of metrics.</p></li><li class="list__item" id="ea453a71_931"><p>you can use Array(LowCardinality(String)) for storing metric names efficiently</p></li><li class="list__item" id="ea453a71_932"><p>good for sparse recording (each time point can have only 1% of all the possible metrics)</p></li></ul></li><li class="list__item" id="ea453a71_933"><p>Cons </p><ul class="list _ul" id="ea453a71_934"><li class="list__item" id="ea453a71_935"><p>you need to extract all metrics for row to reach a single metric</p></li><li class="list__item" id="ea453a71_936"><p>not very handy / complicated non-standard syntax</p></li><li class="list__item" id="ea453a71_937"><p>different metrics values stored in single array (bad compression)</p></li><li class="list__item" id="ea453a71_938"><p>to use values of different datatype you need to cast everything to string or introduce few arrays for values of different types.</p></li></ul></li></ul></section><section class="chapter"><h3 id="2c-using-json" data-toc="2c-using-json"   >2c Using JSON</h3><p id="ea453a71_939">i.e.: timestamp, sourceid, metrics_data_json</p><p id="ea453a71_940">Pros and cons:</p><ul class="list _ul" id="ea453a71_941"><li class="list__item" id="ea453a71_942"><p>Pros </p><ul class="list _ul" id="ea453a71_943"><li class="list__item" id="ea453a71_944"><p>easy to extend, you can have very dynamic / huge number of metrics.</p></li><li class="list__item" id="ea453a71_945"><p>the only option to store hierarchical / complicated data structures, also with arrays etc. inside.</p></li><li class="list__item" id="ea453a71_946"><p>good for sparse recording (each time point can have only 1% of all the possible metrics)</p></li><li class="list__item" id="ea453a71_947"><p>ClickHouse has efficient API to work with JSON</p></li><li class="list__item" id="ea453a71_948"><p>nice if your data originally came in JSON (don't need to reformat)</p></li></ul></li><li class="list__item" id="ea453a71_949"><p>Cons </p><ul class="list _ul" id="ea453a71_950"><li class="list__item" id="ea453a71_951"><p>uses storage non efficiently</p></li><li class="list__item" id="ea453a71_952"><p>different metrics values stored in single array (bad compression)</p></li><li class="list__item" id="ea453a71_953"><p>you need to extract whole JSON field to reach single metric</p></li><li class="list__item" id="ea453a71_954"><p>slower than arrays</p></li></ul></li></ul></section><section class="chapter"><h3 id="2d-using-querystring-format-urls" data-toc="2d-using-querystring-format-urls"   >2d Using querystring-format URLs</h3><p id="ea453a71_955">i.e.: timestamp, sourceid, metrics_querystring Same pros/cons as raw JSON, but usually bit more compact than JSON</p><p id="ea453a71_956">Pros and cons:</p><ul class="list _ul" id="ea453a71_957"><li class="list__item" id="ea453a71_958"><p>Pros </p><ul class="list _ul" id="ea453a71_959"><li class="list__item" id="ea453a71_960"><p>clickhouse has efficient API to work with URLs (extractURLParameter etc)</p></li><li class="list__item" id="ea453a71_961"><p>can have sense if you data came in such format (i.e. you can store GET / POST request data directly w/o reprocessing)</p></li></ul></li><li class="list__item" id="ea453a71_962"><p>Cons </p><ul class="list _ul" id="ea453a71_963"><li class="list__item" id="ea453a71_964"><p>slower than arrays</p></li></ul></li></ul></section><section class="chapter"><h3 id="2e-several-baskets-of-arrays" data-toc="2e-several-baskets-of-arrays"   >2e Several 'baskets' of arrays</h3><p id="ea453a71_965">i.e.: timestamp, sourceid, metric_names_basket1, metric_values_basker1, ..., metric_names_basketN, metric_values_basketN The same as 2b, but there are several key-value arrays ('basket'), and metric go to one particular basket depending on metric name (and optionally by metric type)</p><p id="ea453a71_966">Pros and cons:</p><ul class="list _ul" id="ea453a71_967"><li class="list__item" id="ea453a71_968"><p>Pros </p><ul class="list _ul" id="ea453a71_969"><li class="list__item" id="ea453a71_970"><p>address some disadvantages of 2b (you need to read only single, smaller basket for reaching a value, better compression - less unrelated metrics are mixed together)</p></li></ul></li><li class="list__item" id="ea453a71_971"><p>Cons </p><ul class="list _ul" id="ea453a71_972"><li class="list__item" id="ea453a71_973"><p>complex</p></li></ul></li></ul></section><section class="chapter"><h3 id="2f-combined-approach" data-toc="2f-combined-approach"   >2f Combined approach</h3><p id="ea453a71_974">In real life Pareto principle is correct for many fields.</p><p id="ea453a71_975">For that particular case: usually you need only about 20% of metrics 80% of the time. So you can pick the metrics which are used intensively, and which have a high density, and extract them into separate columns (like in option 2a), leaving the rest in a common 'trash bin' (like in variants 2b-2e).</p><p id="ea453a71_976">With that approach you can have as many metrics as you need and they can be very dynamic. At the same time the most used metrics are stored in special, fine-tuned columns.</p><p id="ea453a71_977">At any time you can decide to move one more metric to a separate column <code class="code" id="ea453a71_978">ALTER TABLE ... ADD COLUMN metricX Float64 MATERIALIZED metrics.value[indexOf(metrics.names,'metricX')];</code></p></section><section class="chapter"><h3 id="2e-subcolumns-future" data-toc="2e-subcolumns-future"   >2e Subcolumns future</h3><p id="ea453a71_979"><a href="https://github.com/ClickHouse/ClickHouse/issues/23516" id="ea453a71_980"   data-external="true" rel="noopener noreferrer" >https://github.com/ClickHouse/ClickHouse/issues/23516</a></p><p id="ea453a71_981">WIP currently, ETA of first beta = autumn 2021</p><p id="ea453a71_982">Related links:</p><p id="ea453a71_983"><a href="https://www.Robinjiang.com/blog/2019/5/23/handling-variable-time-series-efficiently-in-clickhouse"" id="ea453a71_984"   data-external="true" rel="noopener noreferrer" >There is one article on our blog on this subject with some benchmarks.</a></p><p id="ea453a71_985"><a href="https://www.percona.com/sites/default/files/ple19-slides/day1-pm/clickhouse-for-timeseries.pdf"" id="ea453a71_986"   data-external="true" rel="noopener noreferrer" >Slides from Percona Live</a></p><p id="ea453a71_987"><a href="https://eng.uber.com/logging/"" id="ea453a71_988"   data-external="true" rel="noopener noreferrer" >Uber article about how they adapted combined approach</a></p><p id="ea453a71_989"><a href="https://github.com/ClickHouse/clickhouse-presentations/blob/master/meetup40/uber.pdf"" id="ea453a71_990"   data-external="true" rel="noopener noreferrer" >Slides for Uber log storage approach</a></p></section></section><div class="last-modified"> Last modified: 17 十二月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="change-order-by.html">How to change ORDER BY</a>   <a class="navigation-links__next" href="backfill-column.html">Column backfilling with alter/update using a dictionary</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>