<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>知行志</title>
		<link>http://blog.robinjiang.com/</link>
		<description>知行合一!</description>
		<copyright>2020</copyright>
		<pubDate>Fri, 10 Apr 2020 11:41:44 GMT</pubDate>
		<lastBuildDate>Fri, 10 Apr 2020 11:41:44 GMT</lastBuildDate>
		<item>
			<title>关于静态内容生成器和托管环境</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-01-10-about-static-content-generator</link>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-01-10-about-static-content-generator</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;如何选用适用的静态内容生成器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>wyam:基于dotnet的静态内容生成器</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</link>
			<description>&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;劝退指南，目前作者团队已经放弃wyam去开发另外一个项目了&lt;a href="https://github.com/statiqdev"&gt;statiq&lt;/a&gt;,也是一个静态内容生成器，目前该项目还不完整，demo都还不完善&lt;/p&gt;
&lt;p&gt;目前本博就是基于wyam的，如果需要demo的话，可以去这里看&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;本博客 &lt;a href="https://github.com/robin-jiangdh/robin-jiangdh.github.io"&gt;https://github.com/robin-jiangdh/robin-jiangdh.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方网站： &lt;a href="https://github.com/Wyamio/Wyam.web"&gt;https://github.com/Wyamio/Wyam.web&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id="wyam"&gt;Wyam的介绍&lt;/h2&gt;
&lt;p&gt;Wyam.io官网上的自我介绍基本上把Wyam是什么说的很清楚了，我就简单在这里翻译一下。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Wyam是与众不同的。它不是Jekyll的克隆（并不代表Jekyll有任何问题），它不是设计来生成博客的（虽然也能很好的胜任此任务）。Waym是一个静态内容生成器，可以用于生成网站、文档、电子书和其他更多的内容。由于它的所有东西都是通过很多灵活的模块（你也可以编写自己的模块）串在一起，所以唯一的限制是你的想象力。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;自带吐槽技能啊，这个Wyam对标的有点像docfx，不过目标跨的太大，扯着蛋了，后面又另起炉灶了，不过如果你只是用blog功能的话还是可以的，目前算是功能完善&lt;/p&gt;
&lt;p&gt;update 2020-03-24:&lt;/p&gt;
&lt;p&gt;用了两周，目前图片，标签系统或多或少有点bug，tags真心一团糟，我fork了一份自己在维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在它的特性当中，尤其让我看中的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/configuration"&gt;配置文件&lt;/a&gt;使用C#脚本写就，这完全是得益于Roslyn的强大&lt;/li&gt;
&lt;li&gt;简单直接的&lt;a href="http://wyam.io/modules/meta"&gt;元数据&lt;/a&gt;使用方式&lt;/li&gt;
&lt;li&gt;支持多种模板引擎和语言，尤其直接内置&lt;a href="http://wyam.io/modules/razor"&gt;Razor&lt;/a&gt;的支持（且Razor的支持是基于ASP.NET MVC 6的源代码的，未来会支持TagHelper） 。当然也有Markdown支持或者扩展自己的模板语言支持。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/usage"&gt;集成Web Server&lt;/a&gt;方便在编写模板的时候进行预览&lt;/li&gt;
&lt;li&gt;完全&lt;a href="http://wyam.io/getting-started/configuration#nuget"&gt;支持Nuget&lt;/a&gt;，可以在执行生成的过程中，自动下载依赖的Nuget包&lt;/li&gt;
&lt;li&gt;更为重要的，它支持&lt;a href="http://wyam.io/knowledgebase/embedded-use"&gt;嵌入运行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;相对完整清晰的文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Waym其实借鉴了现有其他静态内容生成器的优点和设计，比如FrontMatter的支持（通过Yaml实现）。目前还只是&lt;a href="https://github.com/Wyamio/Wyam/releases/tag/v2.2.9"&gt;v2.2.9&lt;/a&gt;，但是功能完成度还是比较高了，并且你也可以直接pull request参与贡献。源代码地址是：https://github.com/Wyamio/Wyam&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记:关于Paper的阅读-2020年版</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一直在读分布相关的paper，毕业好多年，分布式的领域水真的太深了~，然后读paper各种卡壳，没办法重新翻出这本经典稳固一遍，然后根据stanford的文献整理了这篇博客&lt;/p&gt;
&lt;p&gt;&lt;a href="http://web.stanford.edu/class/cs245/readings/how-to-read-a-paper.pdf"&gt;how-to-read-a-paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍了一种阅读paper方法，帮助大家提高读paper的速度和效率。&lt;/p&gt;
&lt;h2 id="the-three-pass-approach"&gt;三遍阅读法(THE THREE-PASS APPROACH)&lt;/h2&gt;
&lt;p&gt;paper需要读三遍，每一遍都有不同的目标。 第一遍建立一个大体的印象，第二遍把握重要内容，第三遍深入理解。&lt;/p&gt;
&lt;h3 id="the-first-pass"&gt;第一遍(The first pass)&lt;/h3&gt;
&lt;p&gt;第一遍的重点是要快，花五到十分钟快速浏览一遍，获得一个全景印象。 关注如下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仔细阅读标题、摘要、简介(the title, abstract, and introduction)&lt;/li&gt;
&lt;li&gt;阅读章节和子章节的标题(the section and sub-section headings)&lt;/li&gt;
&lt;li&gt;扫一眼数学内容(the mathematical content)，了解理论基础&lt;/li&gt;
&lt;li&gt;阅读结论(the conclusions)&lt;/li&gt;
&lt;li&gt;浏览参考文献(the references)，勾选读过的paper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结束之后，回答5个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类型(Category): 评估(measurement)、系统分析(analysis)、研究原型(research prototype)&lt;/li&gt;
&lt;li&gt;上下文(Context): 相关论文、理论基础&lt;/li&gt;
&lt;li&gt;正确性(Correctness): 假设都成立吗？&lt;/li&gt;
&lt;li&gt;贡献(Contributions)&lt;/li&gt;
&lt;li&gt;清晰度(Clarity): 写的好吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个时候要决定是否继续阅读？是否感兴趣，是否关注这个研究领域，作者是否做了无效的假设。 同样的，如果你自己写paper，也要写好摘要和章节标题，如果读者在五分钟内找不到要点，可能就不会继续阅读了。&lt;/p&gt;
&lt;h3 id="the-second-pass"&gt;第二遍(The second pass)&lt;/h3&gt;
&lt;p&gt;第二遍的重点是要精，仔细阅读每一部分内容，但是注意不要陷入细节。 把自己当成评审员，记下要点、不理解的内容、想问作者的问题，在空白处写下评论。 重点关注图表和插图是否存在错误，这往往是决定一篇paper是否真正优秀的关键。 标注没有读过的参考文献，以便进一步阅读。&lt;/p&gt;
&lt;p&gt;这一遍通常要花费一个小时以上，这个时候应该掌握了paper的内容，可以有足够的论据总结出paper的主旨。 如果这篇paper只是有兴趣，但不是重点研究的领域，到这个程度就可以了。&lt;/p&gt;
&lt;p&gt;有时也有可能没有读懂，这有可能是因为不熟悉这个领域，也可能是论文本身写的不好，也可能是累了。 这个是时候可以有三种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暂时搁置&lt;/li&gt;
&lt;li&gt;了解背景材料后重新阅读&lt;/li&gt;
&lt;li&gt;坚持继续读&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="the-third-pass"&gt;第三遍(The third pass)&lt;/h3&gt;
&lt;p&gt;第三遍的关键是尝试重新实现一遍(virtually reimplement the paper)。 按照作者的假设，提出自己的想法，重新设计实现方案，并与原文的方案进行比较。 关注每一个细节，挑战每一个假设，记录下整个思路，并将有用的证明和技术加入到自己的工具库中。&lt;/p&gt;
&lt;p&gt;通过这样的方式，能够自己从头重建整个系统。 同时可以发现原文存在的问题：能指出隐含的假设，遗漏的实验和潜在的问题。&lt;/p&gt;
&lt;h2 id="literature-survey"&gt;文献分析(literature survey)&lt;/h2&gt;
&lt;p&gt;想深入了解一个领域，仅仅阅读一篇paper是不够的，可能需要读数十篇。 这时需要通过文献分析的方法找到合适的paper，也有三个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的关键词，使用&lt;a href="https://link.zhihu.com/?target=https%3A//scholar.google.com/"&gt;Google Scholar&lt;/a&gt;或&lt;a href="https://link.zhihu.com/?target=https%3A//citeseerx.ist.psu.edu/index"&gt;CiteSeer&lt;/a&gt; 找到该领域最近被引用最多的三到五篇paper&lt;/li&gt;
&lt;li&gt;找到参考文献中引用量最多的作者，他们是这个领域最重要的研究人员，关注他们的最近发布的paper和conferences&lt;/li&gt;
&lt;li&gt;访问这些top conferences的网站，找到最近的高质量paper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反复重复这几个步骤，不断找出这个领域的最重要paper并阅读，不断总结归纳。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>使用mailkit 和mimekit来发送邮件</title>
			<link>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</link>
			<description>&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</guid>
			<pubDate>Thu, 24 Oct 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="mailkitmimekit"&gt;&lt;a href="https://github.com/jstedfast/MailKit"&gt;mailkit&lt;/a&gt;和&lt;a href="https://github.com/jstedfast/MimeKit"&gt;mimekit&lt;/a&gt; 是什么&lt;/h2&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mailkit"&gt;What is MailKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mimekit"&gt;What is MimeKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by &lt;a href="https://github.com/jstedfast/MimeKit/blob/master/RFCs.md"&gt;numerous IETF specifications&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;怎么用&lt;/h2&gt;
&lt;p&gt;分为发信和收信功能&lt;/p&gt;
&lt;h3 id="section-1"&gt;发信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; 
	var message = new MimeMessage ();
	message.From.Add (new MailboxAddress (&amp;quot;Joey Tribbiani&amp;quot;, &amp;quot;joey&amp;#64;friends.com&amp;quot;));
	message.To.Add (new MailboxAddress (&amp;quot;Mrs. Chanandler Bong&amp;quot;, &amp;quot;chandler&amp;#64;friends.com&amp;quot;));
	message.Subject = &amp;quot;How you doin'?&amp;quot;;
    message.Body = new TextPart (&amp;quot;plain&amp;quot;) {
				Text = &amp;#64;&amp;quot;Hey Chandler,
I just wanted to let you know that
Monica and I were going to go play some paintball, you in?
-- Joey&amp;quot;
			};

	using (var client = new SmtpClient ()) {
		// For demo-purposes, 
        //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;smtp.friends.com&amp;quot;, 587, false);

		// Note: only needed if the SMTP server requires authentication
		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		client.Send (message);
		client.Disconnect (true);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-2"&gt;收信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using (var client = new Pop3Client ()) {
	// For demo-purposes, 
    //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;pop.friends.com&amp;quot;, 110, false);

		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		for (int i = 0; i &amp;lt; client.Count; i++) {
			var message = client.GetMessage (i);
			   Console.WriteLine (&amp;quot;Subject: {0}&amp;quot;, message.Subject);
			}
           client.Disconnect (true);
			}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;常见邮件服务提供商及端口&lt;/h2&gt;
&lt;p&gt;【sina.com】
POP3服务器地址:pop3.sina.com.cn（端口：110）
SMTP服务器地址:smtp.sina.com.cn（端口：25）&lt;/p&gt;
&lt;p&gt;【sinaVIP】&lt;/p&gt;
&lt;p&gt;POP3服务器:pop3.vip.sina.com （端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器:smtp.vip.sina.com （端口：25）&lt;/p&gt;
&lt;p&gt;【sohu.com】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop3.sohu.com（端口：110）
SMTP服务器地址:smtp.sohu.com（端口：25）&lt;/p&gt;
&lt;p&gt;【126邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop.126.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址:smtp.126.com（端口：25）&lt;/p&gt;
&lt;p&gt;【139邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：POP.139.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：SMTP.139.com(端口：25)&lt;/p&gt;
&lt;p&gt;【163.com】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop.163.com（端口：110）
SMTP服务器地址:smtp.163.com（端口：25）&lt;/p&gt;
&lt;p&gt;【QQ邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：pop.qq.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：smtp.qq.com（端口：25）&lt;/p&gt;
&lt;p&gt;【QQ企业邮箱】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：pop.exmail.qq.com （SSL启用 端口：995）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：smtp.exmail.qq.com（SSL启用 端口：587/465）&lt;/p&gt;
&lt;p&gt;【yahoo.com】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop.mail.yahoo.com（端口：995）
SMTP服务器地址:smtp.mail.yahoo.com（端口：587)&lt;/p&gt;
&lt;p&gt;【HotMail】&lt;/p&gt;
&lt;p&gt;POP3服务器地址：pop3.live.com（端口：995）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址：smtp.live.com（端口：587）&lt;/p&gt;
&lt;p&gt;【Gmail】
POP3服务器地址:pop.gmail.com（SSL启用端口：995）
SMTP服务器地址:smtp.gmail.com（SSL启用 端口：587）&lt;/p&gt;
&lt;p&gt;【263.net】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:pop3.263.net（端口：110）
SMTP服务器地址:smtp.263.net（端口：25）&lt;/p&gt;
&lt;p&gt;【Foxmail】&lt;/p&gt;
&lt;p&gt;POP3服务器地址:POP.foxmail.com（端口：110）&lt;/p&gt;
&lt;p&gt;SMTP服务器地址:SMTP.foxmail.com（端口：25）&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>生成环境的若干日志实践</title>
			<link>http://blog.robinjiang.com/posts/2018/12/2018-12-20-how-to-logging-in-production-enviroment</link>
			<guid>http://blog.robinjiang.com/posts/2018/12/2018-12-20-how-to-logging-in-production-enviroment</guid>
			<pubDate>Thu, 20 Dec 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;ul&gt;
&lt;li&gt;只记录你需要的日志数据；&lt;/li&gt;
&lt;li&gt;关于日志数据数据中的敏感信息记录问题，账户名可以保留，但银行卡/密码等敏感信息，必须要在源头过滤掉，严禁在日志生成后使用文本处理的方式处理这些字段。&lt;strong&gt;推荐的方式是使用日志模板+关键字过滤的方式来在开发阶段就将这些不规范的日志暴露出来&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;生产环境的日志应该需要包含你的业务细节，而不是流水线日志。如果你的开发框架支持AOP拦截日志的话，先确定你知道如何在生产环境中关闭这些日志，大部分情况下，AOP日志有且仅用于开发环境的debug，生产环境如果用这种方式记录日志的话，那么大部分业务日志都会被这类日志冲垮；&lt;/li&gt;
&lt;li&gt;除了常见的日志级别外，日志系统需要支持简单模式和完整模式的日志；&lt;/li&gt;
&lt;li&gt;日志要尽可能做到不干扰业务正常允许，但允许例外，特定情况下，日志可能是你最后的灾备恢复手段。&lt;/li&gt;
&lt;li&gt;记录日志是一个高IO的操作，条件允许的情况下，不要干扰主业务的io操作。&lt;/li&gt;
&lt;li&gt;善用日志模板，提高日志可读性以及降低日志大小&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记:关于计算机应用类书籍的阅读-2018年版</title>
			<link>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</guid>
			<pubDate>Thu, 16 Aug 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;关于实用性书籍&lt;/h2&gt;
&lt;p&gt;大部分计算机类，除了纯理论书籍外，基本都可以划分到实用性书籍中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在阅读实用性书籍时，先要了解一件事：任何实用性的书籍都不能解决该书所关心的实际问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实用性的书籍主要是针对实际的问题给出解决方式的建议。而实际的问题是需要行动才能够解决的。行动只能在现实发生，不能够在书中发生。每一个问题都有其独特的时间，地点，和特殊的环境。实用性的书籍很难提供完完全全贴合每一个特殊问题的解决方式，它能够提供的是运用在同类型特殊状况中的规则。而问题实际的解决需要读者对规则进行特殊情况的想象，才能在实际状况中进行运用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.实用性书籍分为两种类型：说明规则和说明规则形成的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明规则的实用性书籍，作为读者要寻找的主旨，主要是规则。它一般是在建议某件事情值得做，并且一定会有所收获。比如每天冥想半小时，胜过睡眠10小时。这种类型的书也可能配合规则的原理或者实例来增加叙述内容的可信度。&lt;/p&gt;
&lt;p&gt;说明规则形成原理的书，许多伟大的经济、政治、道德巨著就属于这一类。主旨是在说明某件事情的状态。虽然这类使用性的书籍和纯理论书籍看起来很相似，但是它的核心依然是行动的问题。人们在什么样的情况下能够做得更好或者更糟糕的问题。所以好的读者在阅读这类书籍的时候，会在原理之上，找出实际运用规则的方法。&lt;/p&gt;
&lt;p&gt;而在评价一本实用性的书籍的时候，所有的事情都与结果和目标有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.阅读实用性书籍需要询问的4个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）这本书是在谈论什么？&lt;/p&gt;
&lt;p&gt;（2）作者的主旨和论述是什么？&lt;/p&gt;
&lt;p&gt;（3）内容是真实的吗？&lt;/p&gt;
&lt;p&gt;（4）这本书与我有什么关系？&lt;/p&gt;
&lt;p&gt;当阅读完一般实用性书籍，读者最后觉得作者所说确实有价值，TA会按照作者的建议去行动。如果没有，那表示读者并没有完全的赞同作者提出的规则。&lt;/p&gt;
&lt;h2 id="section-1"&gt;针对计算机专业的书籍有什么特殊&lt;/h2&gt;
&lt;p&gt;上述四个问题基本能解决流程性的问题，但是不能解决实战的问题，目前我也在探索如何高效的吸收一本技术书籍的内容。&lt;/p&gt;
&lt;p&gt;以下是常见的一些问题以及克服办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术类图书的选择，假定同一本书有多个版本，一般情况下选新版的，理论上新版本会追踪该系列的技术堆栈的最新情况，或者说比较接近当前堆栈的最新情况&lt;/li&gt;
&lt;li&gt;相对其他学科，计算机专业的经典图书很少，而且这几年尤其是08年以后，占坑的书目很多，举个例子，之前xxx in Action系列都是不错的好书，后面就烂了招牌。选书之前一定要看样章，但不建议看书评，之前喜欢在知乎和公众号看书评，看完之后毁了不少好书，这些加工过的观点很容易毁掉一本好书&lt;/li&gt;
&lt;li&gt;绝大部分书不如官方文档详尽，嗯，之前手贱买过一本aspnet mvc5的书，作者把几篇blog+官方源码贴出来就发表了，然后全网灌水，从此这个系列一生黑&lt;/li&gt;
&lt;li&gt;关于贴代码的书，代码超过三成以上的书，都不建议购买，纯粹是骗钱的&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>gitlab ci与Powershell 乱码</title>
			<link>http://blog.robinjiang.com/posts/2017/08/2017-08-11-gitlab-ci-powershell-bugs</link>
			<description>&lt;p&gt;存在多种情况下的乱码，应用级别的乱码和控制台乱码
应用级别的乱码类似如下：&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/08/2017-08-11-gitlab-ci-powershell-bugs</guid>
			<pubDate>Fri, 11 Aug 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;存在多种情况下的乱码，应用级别的乱码和控制台乱码
应用级别的乱码类似如下：&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;error MSB1009: ��Ŀ�ļ������ڡ�&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这类需要配置应用的中文输出&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;修改cmd的代码页即可。
一种方法是在cmd的属性中修改默认代码页为437，第二种是用chcp 437命令修改。
不过这两种解决方法的副作用是msbuild的输出会变为英文。
更好的解决方法暂时还没倒腾出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二种，控制台乱码，这个难治，而且原因千奇百怪&lt;/p&gt;
&lt;p&gt;参考方案如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/weixin_43426860/article/details/83348284"&gt;解决windowspowershell中文显示问号及乱码问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cnblogs.com/weihanli/p/fix-Chinese-characters-display-abnormal.html"&gt;Windows 10 powershell 中文乱码解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果以上两种方案都不适用与你的化，那么放大招了，gitlab-ci的宿主系统切换成windows server2016, 实测有效&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>GELF日志格式漫谈</title>
			<link>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</link>
			<description>&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</guid>
			<pubDate>Mon, 12 Jun 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="gelf"&gt;什么是GELF&lt;/h2&gt;
&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="structured-events-from-anywhere.compressed-and-chunked"&gt;Structured events from anywhere. Compressed and chunked.&lt;/h2&gt;
&lt;p&gt;The Graylog Extended Log Format (GELF) is a log format that avoids the shortcomings of classic plain syslog:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Limited to length of 1024 bytes – Not much space for payloads like backtraces&lt;/li&gt;
&lt;li&gt;No data types in structured syslog. You don’t know what is a number and what is a string.&lt;/li&gt;
&lt;li&gt;The RFCs are strict enough but there are so many syslog dialects out there that you cannot possibly parse all of them.&lt;/li&gt;
&lt;li&gt;No compression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://docs.graylog.org/en/2.4/pages/gelf.html#gelf-payload-specification"&gt;GELF 规范&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;A GELF message is a JSON string with the following fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GELF spec version – “1.1”; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;host&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the name of the host, source or application that sent this message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;short_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a short descriptive message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;full_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a long message that can i.e. contain a backtrace; optional.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Seconds since UNIX epoch with optional decimal places for milliseconds; &lt;em&gt;SHOULD&lt;/em&gt; be set by client library. Will be set to the current timestamp (now) by the server if absent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the level equal to the standard syslog levels; optional, default is 1 (ALERT).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;facility&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;line&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the line in a file that caused the error (decimal); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;file&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the file (with path if you want) that caused the error (string); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_[additional field]&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;every field you send and prefix with an underscore (&lt;code&gt;_&lt;/code&gt;) will be treated as an additional field. Allowed characters in field names are any word character (letter, number, underscore), dashes and dots. The verifying regular expression is: &lt;code&gt;^[\w\.\-]*$&lt;/code&gt;. Libraries SHOULD not allow to send id as additional field (&lt;code&gt;_id&lt;/code&gt;). Graylog server nodes omit this field automatically。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="gelf-1"&gt;GELF 能解决什么问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这是个格式规范，能够让绝大部分日志格式相对统一合理，提高日志可读性。&lt;/li&gt;
&lt;li&gt;这是个json规范，实现比较简单。&lt;/li&gt;
&lt;li&gt;由于无视源文本类型，对于绝大部分日志工具类能很好支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelf-2"&gt;实践中，GELF 存在哪些问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是一个非强制性约束，也就意味着，你需要根据现有业务增加更多的约束条件，比如异常堆栈等标准信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连续日志的追踪需要增加更高级别的支持，类似CorrelationID；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于敏感信息过滤问题，假设要实现用户密码字段的过滤，只能通过正则处理生成后的日志文本来过滤，无法前置过滤；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p timestamp="" controllername="" toekn="" postdata=""&gt;日志模板问题，大部分日志是依据格式化的模板生成的，类似“-:-”；日志模板能够极大的降低传输的数据量，很遗憾，这套规范中很难去扩展实现这种模板支持；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Serilog这类提供更多日志信息的库，容易丢失支持的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelfserilogtemplate"&gt;GELF+Serilog+template实践&lt;/h2&gt;
&lt;p&gt;repo近期会迁入github&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>抽象日志组件</title>
			<link>http://blog.robinjiang.com/posts/2017/05/2017-05-10-about-liblog</link>
			<description>&lt;p&gt;本篇是基于&lt;a href="https://github.com/damianh/LibLog"&gt;Liblog&lt;/a&gt; 的结构分析，同时我提倡在非netcore项目中使用此类库，正常情况下只需要在基础组件库中生成单个文件即可，同时一次安装，终身有效。&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/05/2017-05-10-about-liblog</guid>
			<pubDate>Wed, 10 May 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;本篇是基于&lt;a href="https://github.com/damianh/LibLog"&gt;Liblog&lt;/a&gt; 的结构分析，同时我提倡在非netcore项目中使用此类库，正常情况下只需要在基础组件库中生成单个文件即可，同时一次安装，终身有效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志核心功能以接口的方式进行定义，简单有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; interface ILog{
    bool Log(LogLevel logLevel, Func&amp;lt;string&amp;gt; messageFunc, Exception exception = null,
            params object[] formatParameters);
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Liblog的核心是使用提供者模式(Provider Pattern)来实现对各种具体日志实现支持的。调用方面通过 LogProvider.GetCurrentClassLogger() 或者 LogProvider.For() 来获取Ilog的实例。其中GetCurrentClassLogger() 适用与所有静态类或者扩展方法，For()主要用于可实例化的内部。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static readonly ILog logger = LogProvider.GetCurrentClassLogger()
 
private static readonly ILog Logger = LogProvider.For()
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h3 id="section"&gt;两个小问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;日志缓存策略，即生成的日志在本地存在buffer中，后续一次性提交，或者出现了整个日志内容过大，导致无法一次性提交的情况；那么Logproverider.For() 获取的日志实例会出现无法释放的问题，最后只能通过强制GC来释放。解决方案，尽可能控制你的日志文本大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LogProvider.GetCurrentClassLogger()并非是一个线程安全方法，如果需要在Parallel和Task中使用的话，一定要在外部获取实例后传递进去；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于多线程下的日志实践，这个问题比较头大，会单独开一章来描述我的方案&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded>
		</item>
		<item>
			<title>关于Metrics，Tracing和Logging</title>
			<link>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</link>
			<description>&lt;p&gt;这是一篇翻译文章&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</guid>
			<pubDate>Wed, 12 Apr 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;这是一篇翻译文章&lt;/p&gt;
&lt;p&gt;Peter Bourgon 原作： &lt;a href="http://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html"&gt;Metrics, tracing, and logging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，我很荣幸的参加了 2017 分布式追踪峰会(2017 Distributed Tracing Summit)， 并和来自 AWS/X-Ray,
OpenZipkin, OpenTracing, Instana, Datadog, Librato，以及其他更多组织的同仁进行了愉快的沟通和讨论。
其中一个重要的论点，是针对监控项目的范围和定义的。作为一个分布式追踪系统，应该管理日志么?从不同角度看来，到底什么是日志?如何通过一张图形象的定位这些形形色色的系统?&lt;/p&gt;
&lt;p&gt;总体说来，我觉得我们是在一些通用的名词间纠结。我想我们可以通过图表来定义监控的作用域，使各名词的作用范围更明确。 我们使用维恩图(Venn diagram)来描述 Metrics, Tracing, Logging 三个概念的定义。他们三者在某些情况下是重叠的，但是我尽量尝试定义他们的不同。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/01.png" class="img-fluid" alt="Annotated Venn diagram" /&gt;&lt;/p&gt;
&lt;p&gt;Metrics 的特点是，它是可累加的， 他们具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计; 输入 HTTP 请求的数量可以被定义为一个计数器，用于简单累加;请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Logging 的特点是，它描述一些离散的(不连续的)事件。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：应用通过一个滚动的文件输出 Debug 或 Error 信息，并通过日志收集系统，存储到 Elasticsearch 中;
审批明细信息通过 Kafka，存储到数据库(BigTable)中;
又或者，特定请求的元数据信息，从服务请求中剥离出来，发送给一个异常收集服务，如 NewRelic。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tracing 的最大特点就是，它在单次请求的范围内，处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：一次调用远程服务的 RPC 执行过程;一次实际的 SQL 查询语句;一次 HTTP 请求的业务性 ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上述的定义，我们可以标记上图的重叠部分。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/02.png" class="img-fluid" alt="修正的带注释的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;当然，大量的被监控的应用是具有分布式能力(Cloud-native)的应用，逻辑处理在单次请求的范围内完成。因此，讨论追踪的上下文是有意义的。但是，我们注意到，并不是所有的监控系统都绑定在请求的生命周期上的。他们可能是逻辑组件诊断信息、处理过程的生命周期明细信息，这些信息和任何离散的请求时正交关系。&lt;/p&gt;
&lt;p&gt;所以，不是所有的 Metrics 和 Log 都可以被塞进追踪系统的概念中，至少在不经过数据加工处理是不行的。又或者，我们可能发觉使用 Metrics 统计数据，对应用监控有很大帮助，例如 Prometheus 生态，可以量化的实时展现应用视图;相应的，如果我们将 Metrics 统计数据强行使用针对 Log 的管道来处理，将使我们丢失很多特性。&lt;/p&gt;
&lt;p&gt;那么，在这里，我们可以开始对已知的系统进行分类。如：Prometheus，专一的 Metrics 统计系统，随着时间推移，也许会进化为追踪系统，进而进行请求内的指标统计，但不太可能深入到 Log 处理领域。ELK 生态提供 Log 的记录，滚动和聚合，并在其他领域不停的积累更多的特性，并集成进来。&lt;/p&gt;
&lt;p&gt;另外，我发现通过维恩图的方式展现三者关系时，会正巧展现出一个附加效应。在这三个功能域中，Metrics 倾向于更节省资源，因为他会“天然的”压缩数据。相反，日志倾向于无限增加的，会频繁的超出预期的容量。(有另一篇我写的关于这方面的文章，查看，译者注：未翻译)。所以，我们可以在图上，绘制出容量的需求趋势，Metrics 低到 Logging 高，
而 Trace 可能处于他们两的中间位置&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/03.png" class="img-fluid" alt="带有梯度的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;也许，这不是最完美的方式描述这三者的管理，但我从会议现场收到的反馈来看，这个分类还是相当不错的：随着三者的关系越清晰，我们越容易建设性的讨论其他问题。如果你尝试对产品的功能进行定位，你可能也需要这张图。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记：关于碎片化阅读与主题阅读 -2017年版</title>
			<link>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</guid>
			<pubDate>Tue, 21 Feb 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经典值得回味，再过去的一年中，各种读书plan终究敌不过职场压力以及自己的惰性，趁着年假，抽了一天时间重新审阅了这本经典。&lt;/p&gt;
&lt;h2 id="section"&gt;关于碎片化阅读&lt;/h2&gt;
&lt;p&gt;在过去的很长一段时间内，碎片化阅读基本成了我主要的阅读途径，刷微博也好，刷公众号也好，总觉得自己花上三五分钟看完各种总结，技巧，自己就能吸收并为己所用。然并卵，大部分时间花出去之后未获得成效不提，更多的是增加自己的认知焦虑。而解决这种焦虑的根本途径是主题阅读。&lt;/p&gt;
&lt;h2 id="section-1"&gt;关于主题阅读&lt;/h2&gt;
&lt;p&gt;主题阅读分为两个阶段，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主题阅读的准备阶段，这个阶段需要根据你的主题选择合适的书目，在这里你也需要用上检视阅读的技巧；&lt;/li&gt;
&lt;li&gt;阅读阶段，共分为五个步骤，每个步骤都有我们需要学习和改进的地方。&lt;/li&gt;
&lt;li&gt;如何运用主题工具书，这本工具书能够在三方面提供帮助，并且能从三个不同的方向指导关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-2"&gt;准备阶段&lt;/h3&gt;
&lt;p&gt;在这个阶段最重要的就是选书以及对于所选的书有一定的了解。首先在选书阶段，我们可以通过参考图书馆的目录、网络收集、读过的书中的书目索引等途径建立一个自己的书目。其次我们可以通过检视阅读的方式来进行进一步筛选，你要检视你书单上所有的书，合理简化书单并且对自己想要研究的主题有一个清晰的概念，为接下来的阅读阶段做准备。&lt;/p&gt;
&lt;h3 id="section-3"&gt;阅读阶段的五个步骤&lt;/h3&gt;
&lt;p&gt;现在你已经检视了相当多的书,并且对你要研究什么主题了如指掌。接下来就可以正式进入主题阅读的步骤了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;步骤一是找到相关的章节。&lt;/strong&gt; 你首先应该把你选中的每一本书都检视阅读一遍，找出书中与主题相关的章节，我们要抓住一个重点，主题阅读时主题才是我们关心的，而不是书籍本身。&lt;/li&gt;
&lt;li&gt;**步骤二是带引作者与你达成共识。**首先你要建立你的观点，在书中寻找和你观点一致的论据，但是我们要做好心理准备，可能很多作者书中的观点对我们来说都是无用的。&lt;/li&gt;
&lt;li&gt;**步骤三是厘清问题。**我们应该根据主题建立主旨，按照一定的秩序将问题罗列出来，这个秩序要和主题有关，第一个问题和我们研究的现象的特质有关；第二个问题是这个现象如何被发现，最后一个问题是这个现象产生了什么影响。&lt;/li&gt;
&lt;li&gt;**第四个步骤界定议题。**对于一个问题我们在不同的作者口中能够得出多种答案，这时候需要找出不同意见之间的关联，并且根据作者的观点来分类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第五个步骤分析讨论&lt;/strong&gt;。 在最后这个步骤，我们还是要依照特定的顺序来提问题，辨认为什么是这个顺序，我们要说明这些问题的不同答案，并且说明原因。我们也一定要能够从我们检视的书中找出支持我们把答案如此分类的依据，只有做到这些，才算是对我们的问题做了讨论分析，真正了解了问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;如何应用主题工具书&lt;/h2&gt;
&lt;p&gt;主题工具书是为了解决选书的问题。它能告诉你在广泛的材料中到哪里找和主题相关的章节，这能够帮你节省时间。**这本工具书可以从三方面帮助你：即启动阅读，建议阅读和指导阅读。**启动阅读指的是主题工具书能够帮助我们在阅读经典名著时先阅读来自大量不同作者的比较短的章节，避免我们阅读名著的畏难心理；建议阅读指的是在使用工具书进行主题阅读时，还可能激发出对别的主题的兴趣；指导阅读是说主题阅读加上主题工具书，可以帮助读者在某个章节中找出和主题真正相关的地方，强化读者对章节的诠释能力，帮助读者发现某个章节在不同主题中的丰富意义。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>关于redis分布式锁入门</title>
			<link>http://blog.robinjiang.com/posts/2016/08/2019-08-06-redis-distributed-lock</link>
			<description>&lt;p&gt;单一实例下：使用setnx命令(在key不存在时,创建并设置value 返回1,key存在时,会返回0)来获取锁。&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/08/2019-08-06-redis-distributed-lock</guid>
			<pubDate>Sat, 06 Aug 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;原理&lt;/h1&gt;
&lt;p&gt;单一实例下：使用setnx命令(在key不存在时,创建并设置value 返回1,key存在时,会返回0)来获取锁。&lt;/p&gt;
&lt;h1 id="section-1"&gt;应用&lt;/h1&gt;
&lt;p&gt;以扣库存为例，使用锁能够有效保证不会被超卖；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基础版方案：数据库锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT stock from goods where ID =1 for update;
update  goods set stock=stock-1 where id=1 and stock=10
// 正常情况下看你业务需求，如果能够在落库前确认库存的话，上面这句话后面的stock=10能够限定库存锁定值
// 如果不使用这个stock=10的话，会有一定的副作用，比如说常见的，多线程轮扣
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h2 id="redis-v0"&gt;redis 版v0&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​     使用setnx写入一个键值，如果成功则表明获取到锁，执行业务;对于没有获取到锁的，则会轮询获取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            int waitIntervalMs = 50;//间隔等待时长 毫秒
            string lockKey = &amp;quot;lock_key:&amp;quot; + key; 
            DateTime begin = DateTime.Now;
            while (true)
            {
                if (redisClient.SetNX(lockKey, new byte[] { 1 }) == 1)
                {
                    redisClient.Expire(lockKey, expirySeconds);
                    return true;
                } 
                //不等待锁则返回
                if (waitSeconds &amp;lt;= 0)
                    break;

                if ((DateTime.Now - begin).TotalSeconds &amp;gt;= waitSeconds)//等待超时
                    break;

                System.Threading.Thread.Sleep(waitIntervalMs);
            }
            return false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不管是该业务成功、失败或者异常，需要确保该锁在周期结束后能被释放&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redis 版v1&lt;/p&gt;
&lt;p&gt;V0版本存在的缺陷：比较致命的是可能会出现，任务还未完成，锁就超时了，导致key被回收了，那么能不能将锁的申请时间作为值进行存储呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;​```
int waitIntervalMs = 200;//间隔等待时长 毫秒 设置成足够长，至少要超过数据库的超时响应时间
string lockKey = &amp;quot;lock_key:&amp;quot; + key; 
DateTime begin = DateTime.Now;
DateTime now = DateTime.Now;
while (true)
            {
              //在key值存在的情况下
               if(redisclient.ExistKey(lockKey))
               {
               //如果key对应的value值+超时时间后小于当前时间，则移除key值，让业务正常运行
               if(Convert.ToDateTime(redisclient.GetKey(lockkey).Value)+TimeLimit&amp;lt;now){
               redisclient.remove(lockkey);
               }
               }
                if (redisClient.SetNX(lockKey, now.tostring()) == 1)
                {
                    redisClient.Expire(lockKey, expirySeconds);
                    return true;
                } 
                //不等待锁则返回
                if (waitSeconds &amp;lt;= 0)
                    break;

                if ((DateTime.Now - begin).TotalSeconds &amp;gt;= waitSeconds)//等待超时
                    break;

                System.Threading.Thread.Sleep(waitIntervalMs);


            }
            return false; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-2"&gt;遗留的问题&lt;/h1&gt;
&lt;p&gt;在单个redis实例下，上述代码工作都ok，如果存在redis集群，且master挂掉的情况，那么这个锁一定锁不住&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记-2016年版</title>
			<link>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</guid>
			<pubDate>Tue, 15 Mar 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;为什么读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;提高阅读效率&lt;/li&gt;
&lt;li&gt;从更高的层次审阅自己的阅读方式，以期获得更具实用性的阅读技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;读了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;阅读的四个层次：基础阅读，检视阅读，分析阅读，主题阅读&lt;/li&gt;
&lt;li&gt;轻重缓急：对于不同的内容需要审时度势，以判定花费的时间和精力，并非所有的内容都需要一字一句的逐个分析&lt;/li&gt;
&lt;li&gt;大部分文本阅读无需达到分析阅读的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;理解了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果是获取技能或者认知类增长的情况下，主题阅读更有效率&lt;/li&gt;
&lt;li&gt;对于娱乐类型的阅读，建议无脑阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;如何做&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按主题的方式对过往的认知进行归类，并考虑输出成思维导图或技术图谱&lt;/li&gt;
&lt;li&gt;放弃一部分消遣式的阅读&lt;/li&gt;
&lt;li&gt;有必要审视自己的碎片化阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;综合评价&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就这本书而言，翻译有点糟心，考虑继续深读或理解的化，有必要准备英文版本的读&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>MySQL索引原理</title>
			<link>http://blog.robinjiang.com/posts/2016/01/2016-01-15-mysql-index</link>
			<description>&lt;p&gt;我们可以在创建上述索引的时候，为其指定索引类型，分两类：&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/01/2016-01-15-mysql-index</guid>
			<pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;ul&gt;
&lt;li&gt;基本概念
&lt;ul&gt;
&lt;li&gt;索引的功能就是加速查找&lt;/li&gt;
&lt;li&gt;mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常用索引
&lt;ul&gt;
&lt;li&gt;普通索引INDEX：加速查找&lt;/li&gt;
&lt;li&gt;唯一索引：
&lt;ul&gt;
&lt;li&gt;主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）&lt;/li&gt;
&lt;li&gt;唯一索引UNIQUE:加速查找+约束（不能重复）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;联合索引：
&lt;ul&gt;
&lt;li&gt;PRIMARY KEY(id,name):联合主键索引&lt;/li&gt;
&lt;li&gt;UNIQUE(id,name):联合唯一索引&lt;/li&gt;
&lt;li&gt;INDEX(id,name):联合普通索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引的两大类型hash与btree
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们可以在创建上述索引的时候，为其指定索引类型，分两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hash类型的索引：查询单条快，范围查询慢&lt;/li&gt;
&lt;li&gt;btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不同的存储引擎支持的索引类型也不一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；&lt;/li&gt;
&lt;li&gt;MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；&lt;/li&gt;
&lt;li&gt;Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；&lt;/li&gt;
&lt;li&gt;NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；&lt;/li&gt;
&lt;li&gt;Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>索引原理</title>
			<link>http://blog.robinjiang.com/posts/2016/01/2016-01-13-about-index</link>
			<description>&lt;p&gt;对于通用系统而言，大部分数据读操作比例远高于写入操作，针对查询进行优化的时候，优先需要考虑索引优化。&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/01/2016-01-13-about-index</guid>
			<pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;简介&lt;/h1&gt;
&lt;h2 id="section-1"&gt;为什么要有索引？&lt;/h2&gt;
&lt;p&gt;对于通用系统而言，大部分数据读操作比例远高于写入操作，针对查询进行优化的时候，优先需要考虑索引优化。&lt;/p&gt;
&lt;h2 id="section-2"&gt;什么是索引？&lt;/h2&gt;
&lt;p&gt;索引在MySQL中也叫是一种“键”，是存储引擎用于快速找到记录的一种&lt;strong&gt;数据结构&lt;/strong&gt;。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。
索引优化应该是对查询性能优化最有效的手段了。&lt;/p&gt;
&lt;h2 id="section-3"&gt;常见误区&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;索引是不是越多越好？X&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;ul&gt;
&lt;li&gt;索引会增加数据库服务器写入操作的成本（INNODB对这个 做了一个优化：插入缓存 将多次插入合并成一次插入）&lt;/li&gt;
&lt;li&gt;太多的索引会影响mysql查询优化器的选择时间（影响查询效率）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;索引的过度设计问题&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;ul&gt;
&lt;li&gt;索引应该属于专事专办，大部分情况下是&amp;quot;&lt;strong&gt;私人定制&lt;/strong&gt;&amp;quot;款，针对特定sql的索引优化未必适用于其他sql，针对特定业务的索引优化未必适合其他业务；&lt;/li&gt;
&lt;li&gt;** 索引不是万能的，使用索引的初衷是解决查询问题，如果存在其他方案解决的话，应该优先考虑方案的可用性，而不是一定要把问题限制在db内解决**&lt;/li&gt;
&lt;li&gt;索引的适用性问题，blob,img,text这些数据类型不适合用来做索引；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id="section-4"&gt;索引原理&lt;/h1&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;索引是一种利用某种规则的数据结构与实际数据的关系加快数据查找的功能；
索引数据节点中有着实际文件的位置，因为索引是根据特定的规则和算法构建的,在查找的时候遵循索引的规则可以快速查找到对应数据的节点，从而达到快速查找数据的效果；其实宏观来说索引其实是一种概念而不是具体的某项技术，只是我们在某个技术中运用得比较广泛和鲜明（比如说数据库）渐渐的有了特定领域的标签，其实在生活中索引的使用无处不在，比如说：书本里的目录；读书时的座位号，考试编号都有类似索引的功能;
总结来所有通过某规则数据结构和实际目标关联，根据特定规则算法快速寻址的功能都可以称之为索引；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;索引通过特定的数据结构来实现快速数据查找。&lt;/p&gt;
&lt;h2 id="section-5"&gt;索引的数据结构&lt;/h2&gt;
&lt;h3 id="btree"&gt;BTree&lt;/h3&gt;
&lt;p&gt;可以被用在=,&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree&lt;/li&gt;
&lt;li&gt;B+Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hash"&gt;Hash&lt;/h3&gt;
&lt;p&gt;Hash索引只能用于对等比较，例如=,&amp;lt;=&amp;gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。&lt;/p&gt;
&lt;h4 id="section-6"&gt;弊端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引仅仅能满足“=”,“IN”,“&amp;lt;=&amp;gt;”查询，不能使用范围查询。&lt;/li&gt;
&lt;li&gt;联合索引中，Hash索引不能利用部分索引键查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引无法避免数据的排序操作&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引任何时候都不能避免表扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="hash-1"&gt;关于hash索引&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;hash索引查找数据基本上能一次定位数据，当然有大量碰撞的话性能也会下降。而btree索引就得在节点上挨着查找了，很明显在数据精确查找方面hash索引的效率是要高于btree的；&lt;/li&gt;
&lt;li&gt;那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；&lt;/li&gt;
&lt;li&gt;对于btree支持的联合索引的最优前缀，hash也是无法支持的，联合索引中的字段要么全用要么全不用。&lt;/li&gt;
&lt;li&gt;hash不支持索引排序，索引值和计算出来的hash值大小并不一定一致。&lt;/li&gt;
&lt;/ol&gt;
</content:encoded>
		</item>
		<item>
			<title>索引优化原则</title>
			<link>http://blog.robinjiang.com/posts/2016/01/2018-04-11-mysql-index-optimization</link>
			<description>&lt;p&gt;联合索引，mysql会从做向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/01/2018-04-11-mysql-index-optimization</guid>
			<pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;ul&gt;
&lt;li&gt;最左前缀匹配原则&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;联合索引，mysql会从做向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用索引时，索引字段最好小而且唯一，避免select * 的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不冗余原则&lt;/strong&gt;：尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可，建立不必要索引会增加MySQL空间。&lt;strong&gt;基于刚才的最左匹配原则，尽量在原有基础上扩展索引，不要新增索引。 能用单索引，不用联合索引；能用窄索引，不用宽索引；能复用索引，不新建索引&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果确定有多少条数据，使用 limit 限制一下，MySQL在查找到对应条数的数据的时候，会停止继续查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用查询缓存，很多时候MySQL会对查询结果进行cache，但是对应“动态”的数据会不cache，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无法使用cache
1 SELECT username FROM user WHERE signup_date &amp;gt;= CURDATE() 
可以cache
2 SELECT username FROM user WHERE signup_date &amp;gt;= '2017-05-06' 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用了MySQL的一写函数之后，MySQL无法确定结果是易变的，所以不会cache，还有now(),rand()也一样不开启cache&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;join 语法，尽量将小的表放在前面，在需要on的字段上，数据类型保持一致，并设置对应的索引，否则MySQL无法使用索引来join查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在大表上做大量更新时，如果会锁全表，则需要拆分执行，避免长时间锁住表，导致其他请求积累太多（InnoDB 支持行锁，但前提是Where子句需要建立索引，没有索引也一样是锁全表）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  while (1) {
      //每次只做1000条
     mysql_query(&amp;quot;DELETE FROM logs WHERE log_date &amp;lt;= '2009-11-01' LIMIT 1000&amp;quot;);
     if (mysql_affected_rows() == 0) {
          // 没得可删了，退出！
          break;
      }
      // 每次都要休息一会儿
      usleep(50000);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;最大选择性原则
选择区分度高列做索引 什么是区分度高的字段呢？ 一般两种情况不建议建索引： 1、一两千条甚至几百条，没必要建索引，让查询做全表扫描就好了。 因为不是你建了就一定会走索引，执行计划会选择一个最优的方式，msql辅助索引的叶子节点并不直接存储实际数据，只是主建ID，再通过主键索引二次查找。这么一来全表可能很有可能效率更高。 2、索引选择性较低的情况。 所谓选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>MySQL 执行计划</title>
			<link>http://blog.robinjiang.com/posts/2016/01/2017-01-11-mysql-explain-or-desc</link>
			<description>&lt;p&gt;一直在使用Explain，今天被扫盲，专业名词叫执行计划~，野生码农误国啊~&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/01/2017-01-11-mysql-explain-or-desc</guid>
			<pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;一直在使用Explain，今天被扫盲，专业名词叫执行计划~，野生码农误国啊~&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/execution-plan-information.html"&gt;官方文档地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL提供&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/execution-plan-information.html"&gt;&lt;strong&gt;explain/desc&lt;/strong&gt;&lt;/a&gt;命令输出执行计划，我们通过执行计划优化SQL语句&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;根据表，列，索引的详细信息以及&lt;code&gt;WHERE&lt;/code&gt;子句中的条件，MySQL优化器考虑了许多技术来有效执行SQL查询中涉及的查找。无需读取所有行即可执行对巨大表的查询；可以执行涉及多个表的联接，而无需比较行的每个组合。优化器选择执行最有效查询的一组操作称为“ 查询执行计划 ”，也称为 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;计划。您的目标是认识到 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt; 表示查询优化的计划，如果发现一些低效的操作，则可以学习SQL语法和索引技术来改进计划。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="explain"&gt;使用Explain优化查询&lt;/h1&gt;
&lt;p&gt;该&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;语句提供有关MySQL如何执行语句的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;作品有 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html"&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html"&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html"&gt;&lt;code&gt;REPLACE&lt;/code&gt;&lt;/a&gt;，和 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/update.html"&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/a&gt;语句。&lt;/li&gt;
&lt;li&gt;当&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;与可解释的语句一起使用时，MySQL将显示来自优化器的有关语句执行计划的信息。也就是说，MySQL解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。&lt;/li&gt;
&lt;li&gt;当&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;与 &lt;code&gt;FOR CONNECTION *&lt;/code&gt;connection_id&lt;code&gt;*&lt;/code&gt;而不是可解释的语句一起使用时，它将显示在名为这个“connetction_id”的连接中正在执行的语句的执行计划。&lt;/li&gt;
&lt;li&gt;对于&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;语句， 在&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html"&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/a&gt;模式下，&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;可以输出更多的执行计划信息。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;对于检查涉及分区表的查询很有用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FORMAT&lt;/code&gt;选项可用于设置输出格式。&lt;code&gt;TRADITIONAL&lt;/code&gt;以表格格式显示输出。默认情况下不需要提供&lt;code&gt;FORMAT&lt;/code&gt;设置 。 format设置为&lt;code&gt;JSON&lt;/code&gt;时，以JSON格式显示信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="explain-1"&gt;Explain输出格式&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;语句提供有关MySQL如何执行语句的信息。 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;支持 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html"&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html"&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html"&gt;&lt;code&gt;REPLACE&lt;/code&gt;&lt;/a&gt;和 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/update.html"&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/a&gt;语句。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;为&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;语句中使用的每个表返回一行信息 。它按照MySQL在处理语句时读取它们的顺序列出了输出中的表。MySQL使用嵌套循环连接方法解析所有连接。这意味着MySQL从第一个表中读取一行，然后在第二个表，第三个表中找到匹配的行，依此类推。处理完所有表后，MySQL将通过表列表输出选定的列和回溯，直到找到一个表，其中存在更多匹配的行。从该表中读取下一行，然后继续下一个表。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;输出包括分区信息。此外，对于&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt; 语句，&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;产生可与被显示扩展信息 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html"&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/a&gt;之后的 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="explain-2"&gt;扩展的EXPLAIN输出格式&lt;/h3&gt;
&lt;p&gt;对于&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;语句，该 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;语句会产生额外的（“ 扩展 ”）信息，这些信息不属于 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;输出，但可以通过在&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html"&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/a&gt; 以下语句发出来查看&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;。输出中的 &lt;code&gt;Message&lt;/code&gt;值&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html"&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/a&gt;显示优化器如何限定&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;语句 中的表名和列名， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;应用重写和优化规则后的外观以及有关优化过程的其他注释。&lt;/p&gt;
&lt;p&gt;可在&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html"&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/a&gt;语句后面 显示的扩展信息 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;仅针对 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;语句生成。 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html"&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/a&gt;显示其他可解释语句空结果（&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html"&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html"&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html"&gt;&lt;code&gt;REPLACE&lt;/code&gt;&lt;/a&gt;，和 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/update.html"&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/a&gt;）。&lt;/p&gt;
&lt;h1 id="section"&gt;获取命名连接的执行计划信息&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;EXPLAIN [options] FOR CONNECTION connection_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html"&gt;&lt;code&gt;EXPLAIN FOR CONNECTION&lt;/code&gt;&lt;/a&gt;返回&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;当前在给定连接中用于执行查询的信息。由于数据（和支持统计数据）的更改，它可能会产生与&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"&gt;&lt;code&gt;EXPLAIN&lt;/code&gt;&lt;/a&gt;在等效查询文本上运行不同的结果 。行为上的这种差异对于诊断更多瞬时性能问题很有用。例如，如果您在一个需要很长时间才能完成的会话中运行语句，则&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html"&gt;&lt;code&gt;EXPLAIN FOR CONNECTION&lt;/code&gt;&lt;/a&gt;在另一会话中使用该语句可能会产生有关延迟原因的有用信息。&lt;/p&gt;
&lt;p&gt;*&lt;code&gt;connection_id&lt;/code&gt;*是从&lt;code&gt;INFORMATION_SCHEMA&lt;/code&gt; &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html"&gt;&lt;code&gt;PROCESSLIST&lt;/code&gt;&lt;/a&gt;表或 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html"&gt;&lt;code&gt;SHOW PROCESSLIST&lt;/code&gt;&lt;/a&gt;语句获得的连接标识符 。如果有&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_process"&gt;&lt;code&gt;PROCESS&lt;/code&gt;&lt;/a&gt;特权，则可以为任何连接指定标识符。否则，您只能为自己的连接指定标识符。&lt;/p&gt;
&lt;p&gt;如果命名连接未执行语句，则结果为空。否则，&lt;code&gt;EXPLAIN FOR CONNECTION&lt;/code&gt; 仅当在命名连接中执行的语句是可解释的时才适用。这包括 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html"&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html"&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt;， &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html"&gt;&lt;code&gt;REPLACE&lt;/code&gt;&lt;/a&gt;，和 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/update.html"&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/a&gt;。（但是， &lt;code&gt;EXPLAIN FOR CONNECTION&lt;/code&gt;不适用于预备语句，甚至不适用于这些类型的预备语句。）&lt;/p&gt;
&lt;h1 id="section-1"&gt;估计查询性能&lt;/h1&gt;
&lt;p&gt;在大多数情况下，您可以通过计算磁盘搜索次数来估计查询性能。对于小型表，通常可以在一个磁盘搜索中找到一行（因为索引可能已缓存）。对于更大的表，您可以估计，使用B树索引，您需要进行许多查找才能找到行： 。 &lt;code&gt;log(*&lt;/code&gt;row_count&lt;code&gt;*) / log(*&lt;/code&gt;index_block_length&lt;code&gt;* / 3 * 2 / (*&lt;/code&gt;index_length&lt;code&gt;* + *&lt;/code&gt;data_pointer_length&lt;code&gt;*)) + 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在MySQL中，索引块通常为1,024字节，数据指针通常为四个字节。对于一个键值长度为三个字节（大小为&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.html"&gt;&lt;code&gt;MEDIUMINT&lt;/code&gt;&lt;/a&gt;）的500,000行表 ，该公式表示 &lt;code&gt;log(500,000)/log(1024/3*2/(3+4)) + 1&lt;/code&gt;=搜索 &lt;code&gt;4&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该索引将需要大约500,000 * 7 * 3/2 = 5.2MB的存储空间（假设典型的索引缓冲区填充率为2/3），因此您可能在内存中拥有很多索引，因此只需要一个或两个调用即可读取数据以查找行。&lt;/p&gt;
&lt;p&gt;但是，对于写操作，您需要四个搜索请求来查找在何处放置新索引值，通常需要两个搜索来更新索引并写入行。&lt;/p&gt;
&lt;p&gt;前面的讨论并不意味着您的应用程序性能会因log缓慢下降 &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt;。只要所有内容都由OS或MySQL服务器缓存，随着表的增加，事情只会变得稍微慢一些。在数据变得太大而无法缓存之后，事情开始变得缓慢得多，直到您的应用程序仅受磁盘搜索约束（随日志增长 &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt;）。为避免这种情况，请随着数据的增长而增加密钥缓存的大小。对于&lt;code&gt;MyISAM&lt;/code&gt; 表，键缓存大小由&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size"&gt;&lt;code&gt;key_buffer_size&lt;/code&gt;&lt;/a&gt;系统变量控制&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>MySQL中select * for update锁表的范围</title>
			<link>http://blog.robinjiang.com/posts/2016/01/2019-11-15-mysql-lock</link>
			<description>&lt;p&gt;由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/01/2019-11-15-mysql-lock</guid>
			<pubDate>Wed, 13 Jan 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table&lt;/p&gt;
&lt;p&gt;Lock (将整个资料表单给锁住)。 举个例子: 假设有个表单products ，里面有id跟name二个栏位，id是主键。&lt;/p&gt;
&lt;p&gt;例1: (明确指定主键，并且有此笔资料，row lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id='3' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例2: (明确指定主键，若查无此笔资料，无lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id='-1' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例2: (无主键，table lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE name='Mouse' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例3: (主键不明确，table lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id&amp;lt;&amp;gt;'3' FOR UPDATE;&lt;/p&gt;
&lt;p&gt;例4: (主键不明确，table lock)&lt;/p&gt;
&lt;p&gt;SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;
注1: &lt;strong&gt;FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注2: &lt;strong&gt;要测试锁定的状况，可以利用MySQL的Command Mode ，开两个个视窗来做测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注3：Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改修改、删除） 。是表级锁时，不管是否查询到记录，都会锁定表。&lt;/p&gt;
</content:encoded>
		</item>
	</channel>
</rss>