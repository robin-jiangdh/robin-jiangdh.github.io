<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>Robin Log</title>
		<link>http://blog.robinjiang.com/</link>
		<description>Live In an awesome life!</description>
		<copyright>2020</copyright>
		<pubDate>Tue, 07 Apr 2020 07:22:13 GMT</pubDate>
		<lastBuildDate>Tue, 07 Apr 2020 07:22:13 GMT</lastBuildDate>
		<item>
			<title>carbon-一个能生成漂亮的代码截图工具</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-19-carbon-codetools</link>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-19-carbon-codetools</guid>
			<pubDate>Tue, 24 Mar 2020 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>折腾一个新的静态内容生成器wyam</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</link>
			<description>&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;劝退指南，目前作者团队已经放弃wyam去开发另外一个项目了&lt;a href="https://github.com/statiqdev"&gt;statiq&lt;/a&gt;,也是一个静态内容生成器，目前该项目还不完整，demo都还不完善&lt;/p&gt;
&lt;p&gt;目前本博就是基于wyam的，如果需要demo的话，可以去这里看&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;本博客 &lt;a href="https://github.com/robin-jiangdh/robin-jiangdh.github.io"&gt;https://github.com/robin-jiangdh/robin-jiangdh.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方网站： &lt;a href="https://github.com/Wyamio/Wyam.web"&gt;https://github.com/Wyamio/Wyam.web&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id="wyam"&gt;Wyam的介绍&lt;/h2&gt;
&lt;p&gt;Wyam.io官网上的自我介绍基本上把Wyam是什么说的很清楚了，我就简单在这里翻译一下。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Wyam是与众不同的。它不是Jekyll的克隆（并不代表Jekyll有任何问题），它不是设计来生成博客的（虽然也能很好的胜任此任务）。Waym是一个静态内容生成器，可以用于生成网站、文档、电子书和其他更多的内容。由于它的所有东西都是通过很多灵活的模块（你也可以编写自己的模块）串在一起，所以唯一的限制是你的想象力。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;自带吐槽技能啊，这个Wyam对标的有点像docfx，不过目标跨的太大，扯着蛋了，后面又另起炉灶了，不过如果你只是用blog功能的话还是可以的，目前算是功能完善&lt;/p&gt;
&lt;p&gt;update 2020-03-24:&lt;/p&gt;
&lt;p&gt;用了两周，目前图片，标签系统或多或少有点bug，tags真心一团糟，我fork了一份自己在维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在它的特性当中，尤其让我看中的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/configuration"&gt;配置文件&lt;/a&gt;使用C#脚本写就，这完全是得益于Roslyn的强大&lt;/li&gt;
&lt;li&gt;简单直接的&lt;a href="http://wyam.io/modules/meta"&gt;元数据&lt;/a&gt;使用方式&lt;/li&gt;
&lt;li&gt;支持多种模板引擎和语言，尤其直接内置&lt;a href="http://wyam.io/modules/razor"&gt;Razor&lt;/a&gt;的支持（且Razor的支持是基于ASP.NET MVC 6的源代码的，未来会支持TagHelper） 。当然也有Markdown支持或者扩展自己的模板语言支持。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/usage"&gt;集成Web Server&lt;/a&gt;方便在编写模板的时候进行预览&lt;/li&gt;
&lt;li&gt;完全&lt;a href="http://wyam.io/getting-started/configuration#nuget"&gt;支持Nuget&lt;/a&gt;，可以在执行生成的过程中，自动下载依赖的Nuget包&lt;/li&gt;
&lt;li&gt;更为重要的，它支持&lt;a href="http://wyam.io/knowledgebase/embedded-use"&gt;嵌入运行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;相对完整清晰的文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Waym其实借鉴了现有其他静态内容生成器的优点和设计，比如FrontMatter的支持（通过Yaml实现）。目前还只是&lt;a href="https://github.com/Wyamio/Wyam/releases/tag/v2.2.9"&gt;v2.2.9&lt;/a&gt;，但是功能完成度还是比较高了，并且你也可以直接pull request参与贡献。源代码地址是：https://github.com/Wyamio/Wyam&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记:关于Paper的阅读-2020年版</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一直在读分布相关的paper，毕业好多年，分布式的领域水真的太深了~，然后读paper各种卡壳，没办法重新翻出这本经典稳固一遍，然后根据stanford的文献整理了这篇博客&lt;/p&gt;
&lt;p&gt;&lt;a href="http://web.stanford.edu/class/cs245/readings/how-to-read-a-paper.pdf"&gt;how-to-read-a-paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍了一种阅读paper方法，帮助大家提高读paper的速度和效率。&lt;/p&gt;
&lt;h2 id="the-three-pass-approach"&gt;三遍阅读法(THE THREE-PASS APPROACH)&lt;/h2&gt;
&lt;p&gt;paper需要读三遍，每一遍都有不同的目标。 第一遍建立一个大体的印象，第二遍把握重要内容，第三遍深入理解。&lt;/p&gt;
&lt;h3 id="the-first-pass"&gt;第一遍(The first pass)&lt;/h3&gt;
&lt;p&gt;第一遍的重点是要快，花五到十分钟快速浏览一遍，获得一个全景印象。 关注如下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仔细阅读标题、摘要、简介(the title, abstract, and introduction)&lt;/li&gt;
&lt;li&gt;阅读章节和子章节的标题(the section and sub-section headings)&lt;/li&gt;
&lt;li&gt;扫一眼数学内容(the mathematical content)，了解理论基础&lt;/li&gt;
&lt;li&gt;阅读结论(the conclusions)&lt;/li&gt;
&lt;li&gt;浏览参考文献(the references)，勾选读过的paper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结束之后，回答5个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类型(Category): 评估(measurement)、系统分析(analysis)、研究原型(research prototype)&lt;/li&gt;
&lt;li&gt;上下文(Context): 相关论文、理论基础&lt;/li&gt;
&lt;li&gt;正确性(Correctness): 假设都成立吗？&lt;/li&gt;
&lt;li&gt;贡献(Contributions)&lt;/li&gt;
&lt;li&gt;清晰度(Clarity): 写的好吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个时候要决定是否继续阅读？是否感兴趣，是否关注这个研究领域，作者是否做了无效的假设。 同样的，如果你自己写paper，也要写好摘要和章节标题，如果读者在五分钟内找不到要点，可能就不会继续阅读了。&lt;/p&gt;
&lt;h3 id="the-second-pass"&gt;第二遍(The second pass)&lt;/h3&gt;
&lt;p&gt;第二遍的重点是要精，仔细阅读每一部分内容，但是注意不要陷入细节。 把自己当成评审员，记下要点、不理解的内容、想问作者的问题，在空白处写下评论。 重点关注图表和插图是否存在错误，这往往是决定一篇paper是否真正优秀的关键。 标注没有读过的参考文献，以便进一步阅读。&lt;/p&gt;
&lt;p&gt;这一遍通常要花费一个小时以上，这个时候应该掌握了paper的内容，可以有足够的论据总结出paper的主旨。 如果这篇paper只是有兴趣，但不是重点研究的领域，到这个程度就可以了。&lt;/p&gt;
&lt;p&gt;有时也有可能没有读懂，这有可能是因为不熟悉这个领域，也可能是论文本身写的不好，也可能是累了。 这个是时候可以有三种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暂时搁置&lt;/li&gt;
&lt;li&gt;了解背景材料后重新阅读&lt;/li&gt;
&lt;li&gt;坚持继续读&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="the-third-pass"&gt;第三遍(The third pass)&lt;/h3&gt;
&lt;p&gt;第三遍的关键是尝试重新实现一遍(virtually reimplement the paper)。 按照作者的假设，提出自己的想法，重新设计实现方案，并与原文的方案进行比较。 关注每一个细节，挑战每一个假设，记录下整个思路，并将有用的证明和技术加入到自己的工具库中。&lt;/p&gt;
&lt;p&gt;通过这样的方式，能够自己从头重建整个系统。 同时可以发现原文存在的问题：能指出隐含的假设，遗漏的实验和潜在的问题。&lt;/p&gt;
&lt;h2 id="literature-survey"&gt;文献分析(literature survey)&lt;/h2&gt;
&lt;p&gt;想深入了解一个领域，仅仅阅读一篇paper是不够的，可能需要读数十篇。 这时需要通过文献分析的方法找到合适的paper，也有三个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的关键词，使用&lt;a href="https://link.zhihu.com/?target=https%3A//scholar.google.com/"&gt;Google Scholar&lt;/a&gt;或&lt;a href="https://link.zhihu.com/?target=https%3A//citeseerx.ist.psu.edu/index"&gt;CiteSeer&lt;/a&gt; 找到该领域最近被引用最多的三到五篇paper&lt;/li&gt;
&lt;li&gt;找到参考文献中引用量最多的作者，他们是这个领域最重要的研究人员，关注他们的最近发布的paper和conferences&lt;/li&gt;
&lt;li&gt;访问这些top conferences的网站，找到最近的高质量paper&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反复重复这几个步骤，不断找出这个领域的最重要paper并阅读，不断总结归纳。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>使用mailkit 和mimekit来发送邮件</title>
			<link>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</link>
			<description>&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</guid>
			<pubDate>Thu, 24 Oct 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="mailkitmimekit"&gt;&lt;a href="https://github.com/jstedfast/MailKit"&gt;mailkit&lt;/a&gt;和&lt;a href="https://github.com/jstedfast/MimeKit"&gt;mimekit&lt;/a&gt; 是什么&lt;/h2&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mailkit"&gt;What is MailKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mimekit"&gt;What is MimeKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by &lt;a href="https://github.com/jstedfast/MimeKit/blob/master/RFCs.md"&gt;numerous IETF specifications&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;怎么用&lt;/h2&gt;
&lt;p&gt;分为发信和收信功能&lt;/p&gt;
&lt;h3 id="section-1"&gt;发信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; 
	var message = new MimeMessage ();
	message.From.Add (new MailboxAddress (&amp;quot;Joey Tribbiani&amp;quot;, &amp;quot;joey&amp;#64;friends.com&amp;quot;));
	message.To.Add (new MailboxAddress (&amp;quot;Mrs. Chanandler Bong&amp;quot;, &amp;quot;chandler&amp;#64;friends.com&amp;quot;));
	message.Subject = &amp;quot;How you doin'?&amp;quot;;
    message.Body = new TextPart (&amp;quot;plain&amp;quot;) {
				Text = &amp;#64;&amp;quot;Hey Chandler,
I just wanted to let you know that
Monica and I were going to go play some paintball, you in?
-- Joey&amp;quot;
			};

	using (var client = new SmtpClient ()) {
		// For demo-purposes, 
        //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;smtp.friends.com&amp;quot;, 587, false);

		// Note: only needed if the SMTP server requires authentication
		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		client.Send (message);
		client.Disconnect (true);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-2"&gt;收信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using (var client = new Pop3Client ()) {
	// For demo-purposes, 
    //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;pop.friends.com&amp;quot;, 110, false);

		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		for (int i = 0; i &amp;lt; client.Count; i++) {
			var message = client.GetMessage (i);
			   Console.WriteLine (&amp;quot;Subject: {0}&amp;quot;, message.Subject);
			}
           client.Disconnect (true);
			}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记:关于计算机应用类书籍的阅读-2018年版</title>
			<link>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</guid>
			<pubDate>Thu, 16 Aug 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;关于实用性书籍&lt;/h2&gt;
&lt;p&gt;大部分计算机类，除了纯理论书籍外，基本都可以划分到实用性书籍中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在阅读实用性书籍时，先要了解一件事：任何实用性的书籍都不能解决该书所关心的实际问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实用性的书籍主要是针对实际的问题给出解决方式的建议。而实际的问题是需要行动才能够解决的。行动只能在现实发生，不能够在书中发生。每一个问题都有其独特的时间，地点，和特殊的环境。实用性的书籍很难提供完完全全贴合每一个特殊问题的解决方式，它能够提供的是运用在同类型特殊状况中的规则。而问题实际的解决需要读者对规则进行特殊情况的想象，才能在实际状况中进行运用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.实用性书籍分为两种类型：说明规则和说明规则形成的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明规则的实用性书籍，作为读者要寻找的主旨，主要是规则。它一般是在建议某件事情值得做，并且一定会有所收获。比如每天冥想半小时，胜过睡眠10小时。这种类型的书也可能配合规则的原理或者实例来增加叙述内容的可信度。&lt;/p&gt;
&lt;p&gt;说明规则形成原理的书，许多伟大的经济、政治、道德巨著就属于这一类。主旨是在说明某件事情的状态。虽然这类使用性的书籍和纯理论书籍看起来很相似，但是它的核心依然是行动的问题。人们在什么样的情况下能够做得更好或者更糟糕的问题。所以好的读者在阅读这类书籍的时候，会在原理之上，找出实际运用规则的方法。&lt;/p&gt;
&lt;p&gt;而在评价一本实用性的书籍的时候，所有的事情都与结果和目标有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.阅读实用性书籍需要询问的4个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）这本书是在谈论什么？&lt;/p&gt;
&lt;p&gt;（2）作者的主旨和论述是什么？&lt;/p&gt;
&lt;p&gt;（3）内容是真实的吗？&lt;/p&gt;
&lt;p&gt;（4）这本书与我有什么关系？&lt;/p&gt;
&lt;p&gt;当阅读完一般实用性书籍，读者最后觉得作者所说确实有价值，TA会按照作者的建议去行动。如果没有，那表示读者并没有完全的赞同作者提出的规则。&lt;/p&gt;
&lt;h2 id="section-1"&gt;针对计算机专业的书籍有什么特殊&lt;/h2&gt;
&lt;p&gt;上述四个问题基本能解决流程性的问题，但是不能解决实战的问题，目前我也在探索如何高效的吸收一本技术书籍的内容。&lt;/p&gt;
&lt;p&gt;以下是常见的一些问题以及克服办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术类图书的选择，假定同一本书有多个版本，一般情况下选新版的，理论上新版本会追踪该系列的技术堆栈的最新情况，或者说比较接近当前堆栈的最新情况&lt;/li&gt;
&lt;li&gt;相对其他学科，计算机专业的经典图书很少，而且这几年尤其是08年以后，占坑的书目很多，举个例子，之前xxx in Action系列都是不错的好书，后面就烂了招牌。选书之前一定要看样章，但不建议看书评，之前喜欢在知乎和公众号看书评，看完之后毁了不少好书，这些加工过的观点很容易毁掉一本好书&lt;/li&gt;
&lt;li&gt;绝大部分书不如官方文档详尽，嗯，之前手贱买过一本aspnet mvc5的书，作者把几篇blog+官方源码贴出来就发表了，然后全网灌水，从此这个系列一生黑&lt;/li&gt;
&lt;li&gt;关于贴代码的书，代码超过三成以上的书，都不建议购买，纯粹是骗钱的&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>GELF日志格式漫谈</title>
			<link>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</link>
			<description>&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</guid>
			<pubDate>Mon, 12 Jun 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="gelf"&gt;什么是GELF&lt;/h2&gt;
&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="structured-events-from-anywhere.compressed-and-chunked"&gt;Structured events from anywhere. Compressed and chunked.&lt;/h2&gt;
&lt;p&gt;The Graylog Extended Log Format (GELF) is a log format that avoids the shortcomings of classic plain syslog:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Limited to length of 1024 bytes – Not much space for payloads like backtraces&lt;/li&gt;
&lt;li&gt;No data types in structured syslog. You don’t know what is a number and what is a string.&lt;/li&gt;
&lt;li&gt;The RFCs are strict enough but there are so many syslog dialects out there that you cannot possibly parse all of them.&lt;/li&gt;
&lt;li&gt;No compression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://docs.graylog.org/en/2.4/pages/gelf.html#gelf-payload-specification"&gt;GELF 规范&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;A GELF message is a JSON string with the following fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GELF spec version – “1.1”; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;host&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the name of the host, source or application that sent this message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;short_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a short descriptive message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;full_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a long message that can i.e. contain a backtrace; optional.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Seconds since UNIX epoch with optional decimal places for milliseconds; &lt;em&gt;SHOULD&lt;/em&gt; be set by client library. Will be set to the current timestamp (now) by the server if absent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the level equal to the standard syslog levels; optional, default is 1 (ALERT).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;facility&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;line&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the line in a file that caused the error (decimal); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;file&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the file (with path if you want) that caused the error (string); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_[additional field]&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;every field you send and prefix with an underscore (&lt;code&gt;_&lt;/code&gt;) will be treated as an additional field. Allowed characters in field names are any word character (letter, number, underscore), dashes and dots. The verifying regular expression is: &lt;code&gt;^[\w\.\-]*$&lt;/code&gt;. Libraries SHOULD not allow to send id as additional field (&lt;code&gt;_id&lt;/code&gt;). Graylog server nodes omit this field automatically。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="gelf-1"&gt;GELF 能解决什么问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这是个格式规范，能够让绝大部分日志格式相对统一合理，提高日志可读性。&lt;/li&gt;
&lt;li&gt;这是个json规范，实现比较简单。&lt;/li&gt;
&lt;li&gt;由于无视源文本类型，对于绝大部分日志工具类能很好支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelf-2"&gt;实践中，GELF 存在哪些问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是一个非强制性约束，也就意味着，你需要根据现有业务增加更多的约束条件，比如异常堆栈等标准信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连续日志的追踪需要增加更高级别的支持，类似CorrelationID；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于敏感信息过滤问题，假设要实现用户密码字段的过滤，只能通过正则处理生成后的日志文本来过滤，无法前置过滤；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p timestamp="" controllername="" toekn="" postdata=""&gt;日志模板问题，大部分日志是依据格式化的模板生成的，类似“-:-”；日志模板能够极大的降低传输的数据量，很遗憾，这套规范中很难去扩展实现这种模板支持；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Serilog这类提供更多日志信息的库，容易丢失支持的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelfserilogtemplate"&gt;GELF+Serilog+template实践&lt;/h2&gt;
&lt;p&gt;repo近期会迁入github&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>关于Metrics，Tracing和Logging</title>
			<link>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</link>
			<description>&lt;p&gt;这是一篇翻译文章&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</guid>
			<pubDate>Wed, 12 Apr 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;这是一篇翻译文章&lt;/p&gt;
&lt;p&gt;Peter Bourgon 原作： &lt;a href="http://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html"&gt;Metrics, tracing, and logging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，我很荣幸的参加了 2017 分布式追踪峰会(2017 Distributed Tracing Summit)， 并和来自 AWS/X-Ray,
OpenZipkin, OpenTracing, Instana, Datadog, Librato，以及其他更多组织的同仁进行了愉快的沟通和讨论。
其中一个重要的论点，是针对监控项目的范围和定义的。作为一个分布式追踪系统，应该管理日志么?从不同角度看来，到底什么是日志?如何通过一张图形象的定位这些形形色色的系统?&lt;/p&gt;
&lt;p&gt;总体说来，我觉得我们是在一些通用的名词间纠结。我想我们可以通过图表来定义监控的作用域，使各名词的作用范围更明确。 我们使用维恩图(Venn diagram)来描述 Metrics, Tracing, Logging 三个概念的定义。他们三者在某些情况下是重叠的，但是我尽量尝试定义他们的不同。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/01.png" class="img-fluid" alt="Annotated Venn diagram" /&gt;&lt;/p&gt;
&lt;p&gt;Metrics 的特点是，它是可累加的， 他们具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计; 输入 HTTP 请求的数量可以被定义为一个计数器，用于简单累加;请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Logging 的特点是，它描述一些离散的(不连续的)事件。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：应用通过一个滚动的文件输出 Debug 或 Error 信息，并通过日志收集系统，存储到 Elasticsearch 中;
审批明细信息通过 Kafka，存储到数据库(BigTable)中;
又或者，特定请求的元数据信息，从服务请求中剥离出来，发送给一个异常收集服务，如 NewRelic。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tracing 的最大特点就是，它在单次请求的范围内，处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：一次调用远程服务的 RPC 执行过程;一次实际的 SQL 查询语句;一次 HTTP 请求的业务性 ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上述的定义，我们可以标记上图的重叠部分。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/02.png" class="img-fluid" alt="修正的带注释的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;当然，大量的被监控的应用是具有分布式能力(Cloud-native)的应用，逻辑处理在单次请求的范围内完成。因此，讨论追踪的上下文是有意义的。但是，我们注意到，并不是所有的监控系统都绑定在请求的生命周期上的。他们可能是逻辑组件诊断信息、处理过程的生命周期明细信息，这些信息和任何离散的请求时正交关系。&lt;/p&gt;
&lt;p&gt;所以，不是所有的 Metrics 和 Log 都可以被塞进追踪系统的概念中，至少在不经过数据加工处理是不行的。又或者，我们可能发觉使用 Metrics 统计数据，对应用监控有很大帮助，例如 Prometheus 生态，可以量化的实时展现应用视图;相应的，如果我们将 Metrics 统计数据强行使用针对 Log 的管道来处理，将使我们丢失很多特性。&lt;/p&gt;
&lt;p&gt;那么，在这里，我们可以开始对已知的系统进行分类。如：Prometheus，专一的 Metrics 统计系统，随着时间推移，也许会进化为追踪系统，进而进行请求内的指标统计，但不太可能深入到 Log 处理领域。ELK 生态提供 Log 的记录，滚动和聚合，并在其他领域不停的积累更多的特性，并集成进来。&lt;/p&gt;
&lt;p&gt;另外，我发现通过维恩图的方式展现三者关系时，会正巧展现出一个附加效应。在这三个功能域中，Metrics 倾向于更节省资源，因为他会“天然的”压缩数据。相反，日志倾向于无限增加的，会频繁的超出预期的容量。(有另一篇我写的关于这方面的文章，查看，译者注：未翻译)。所以，我们可以在图上，绘制出容量的需求趋势，Metrics 低到 Logging 高，
而 Trace 可能处于他们两的中间位置&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/03.png" class="img-fluid" alt="带有梯度的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;也许，这不是最完美的方式描述这三者的管理，但我从会议现场收到的反馈来看，这个分类还是相当不错的：随着三者的关系越清晰，我们越容易建设性的讨论其他问题。如果你尝试对产品的功能进行定位，你可能也需要这张图。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记：关于碎片化阅读与主题阅读 -2017年版</title>
			<link>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</guid>
			<pubDate>Tue, 21 Feb 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经典值得回味，再过去的一年中，各种读书plan终究敌不过职场压力以及自己的惰性，趁着年假，抽了一天时间重新审阅了这本经典。&lt;/p&gt;
&lt;h2 id="section"&gt;关于碎片化阅读&lt;/h2&gt;
&lt;p&gt;在过去的很长一段时间内，碎片化阅读基本成了我主要的阅读途径，刷微博也好，刷公众号也好，总觉得自己花上三五分钟看完各种总结，技巧，自己就能吸收并为己所用。然并卵，大部分时间花出去之后未获得成效不提，更多的是增加自己的认知焦虑。而解决这种焦虑的根本途径是主题阅读。&lt;/p&gt;
&lt;h2 id="section-1"&gt;关于主题阅读&lt;/h2&gt;
&lt;p&gt;主题阅读分为两个阶段，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主题阅读的准备阶段，这个阶段需要根据你的主题选择合适的书目，在这里你也需要用上检视阅读的技巧；&lt;/li&gt;
&lt;li&gt;阅读阶段，共分为五个步骤，每个步骤都有我们需要学习和改进的地方。&lt;/li&gt;
&lt;li&gt;如何运用主题工具书，这本工具书能够在三方面提供帮助，并且能从三个不同的方向指导关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-2"&gt;准备阶段&lt;/h3&gt;
&lt;p&gt;在这个阶段最重要的就是选书以及对于所选的书有一定的了解。首先在选书阶段，我们可以通过参考图书馆的目录、网络收集、读过的书中的书目索引等途径建立一个自己的书目。其次我们可以通过检视阅读的方式来进行进一步筛选，你要检视你书单上所有的书，合理简化书单并且对自己想要研究的主题有一个清晰的概念，为接下来的阅读阶段做准备。&lt;/p&gt;
&lt;h3 id="section-3"&gt;阅读阶段的五个步骤&lt;/h3&gt;
&lt;p&gt;现在你已经检视了相当多的书,并且对你要研究什么主题了如指掌。接下来就可以正式进入主题阅读的步骤了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;步骤一是找到相关的章节。&lt;/strong&gt; 你首先应该把你选中的每一本书都检视阅读一遍，找出书中与主题相关的章节，我们要抓住一个重点，主题阅读时主题才是我们关心的，而不是书籍本身。&lt;/li&gt;
&lt;li&gt;**步骤二是带引作者与你达成共识。**首先你要建立你的观点，在书中寻找和你观点一致的论据，但是我们要做好心理准备，可能很多作者书中的观点对我们来说都是无用的。&lt;/li&gt;
&lt;li&gt;**步骤三是厘清问题。**我们应该根据主题建立主旨，按照一定的秩序将问题罗列出来，这个秩序要和主题有关，第一个问题和我们研究的现象的特质有关；第二个问题是这个现象如何被发现，最后一个问题是这个现象产生了什么影响。&lt;/li&gt;
&lt;li&gt;**第四个步骤界定议题。**对于一个问题我们在不同的作者口中能够得出多种答案，这时候需要找出不同意见之间的关联，并且根据作者的观点来分类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第五个步骤分析讨论&lt;/strong&gt;。 在最后这个步骤，我们还是要依照特定的顺序来提问题，辨认为什么是这个顺序，我们要说明这些问题的不同答案，并且说明原因。我们也一定要能够从我们检视的书中找出支持我们把答案如此分类的依据，只有做到这些，才算是对我们的问题做了讨论分析，真正了解了问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;如何应用主题工具书&lt;/h2&gt;
&lt;p&gt;主题工具书是为了解决选书的问题。它能告诉你在广泛的材料中到哪里找和主题相关的章节，这能够帮你节省时间。**这本工具书可以从三方面帮助你：即启动阅读，建议阅读和指导阅读。**启动阅读指的是主题工具书能够帮助我们在阅读经典名著时先阅读来自大量不同作者的比较短的章节，避免我们阅读名著的畏难心理；建议阅读指的是在使用工具书进行主题阅读时，还可能激发出对别的主题的兴趣；指导阅读是说主题阅读加上主题工具书，可以帮助读者在某个章节中找出和主题真正相关的地方，强化读者对章节的诠释能力，帮助读者发现某个章节在不同主题中的丰富意义。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记-2016年版</title>
			<link>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</guid>
			<pubDate>Tue, 15 Mar 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="http://blog.robinjiang.com/posts/asset/2016-03-15-How-to-Read-a-Book/s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;&lt;/p&gt;
&lt;p&gt;如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;为什么读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;提高阅读效率&lt;/li&gt;
&lt;li&gt;从更高的层次审阅自己的阅读方式，以期获得更具实用性的阅读技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;读了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;阅读的四个层次：基础阅读，检视阅读，分析阅读，主题阅读&lt;/li&gt;
&lt;li&gt;轻重缓急：对于不同的内容需要审时度势，以判定花费的时间和精力，并非所有的内容都需要一字一句的逐个分析&lt;/li&gt;
&lt;li&gt;大部分文本阅读无需达到分析阅读的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;理解了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果是获取技能或者认知类增长的情况下，主题阅读更有效率&lt;/li&gt;
&lt;li&gt;对于娱乐类型的阅读，建议无脑阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;如何做&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按主题的方式对过往的认知进行归类，并考虑输出成思维导图或技术图谱&lt;/li&gt;
&lt;li&gt;放弃一部分消遣式的阅读&lt;/li&gt;
&lt;li&gt;有必要审视自己的碎片化阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;综合评价&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就这本书而言，翻译有点糟心，考虑继续深读或理解的化，有必要准备英文版本的读&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
	</channel>
</rss>