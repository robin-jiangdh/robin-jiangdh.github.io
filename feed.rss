<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>Robin Log</title>
		<link>http://blog.robinjiang.com/</link>
		<description>Live In an awesome life!</description>
		<copyright>2020</copyright>
		<pubDate>Tue, 07 Apr 2020 05:41:49 GMT</pubDate>
		<lastBuildDate>Tue, 07 Apr 2020 05:41:49 GMT</lastBuildDate>
		<item>
			<title>carbon-一个能生成漂亮的代码截图工具</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-19-carbon-codetools</link>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-19-carbon-codetools</guid>
			<pubDate>Tue, 24 Mar 2020 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记-2020年版</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</link>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-10-How-to-Read-a-Book</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>折腾一个新的静态内容生成器wyam</title>
			<link>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</link>
			<description>&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2020/03/2020-03-10-wyam-static-content-generator-and-toolkit</guid>
			<pubDate>Tue, 10 Mar 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;vps到期了，然后疫情原因，一直没时间去管，去续费的时候才发现之前写的东西全丢了，现在只能挨个找之前的备份，痛定思痛，准备找个大概率不会挂机的服务商了，然后就盯上了github-page,用于托管点博客是够了，而且咱这种也不靠博客盈利的，纯粹就是找个垃圾桶写文章而已，够了够了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;劝退指南，目前作者团队已经放弃wyam去开发另外一个项目了&lt;a href="https://github.com/statiqdev"&gt;statiq&lt;/a&gt;,也是一个静态内容生成器，目前该项目还不完整，demo都还不完善&lt;/p&gt;
&lt;p&gt;目前本博就是基于wyam的，如果需要demo的话，可以去这里看&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;本博客 &lt;a href="https://github.com/robin-jiangdh/robin-jiangdh.github.io"&gt;https://github.com/robin-jiangdh/robin-jiangdh.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方网站： &lt;a href="https://github.com/Wyamio/Wyam.web"&gt;https://github.com/Wyamio/Wyam.web&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id="wyam"&gt;Wyam的介绍&lt;/h2&gt;
&lt;p&gt;Wyam.io官网上的自我介绍基本上把Wyam是什么说的很清楚了，我就简单在这里翻译一下。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Wyam是与众不同的。它不是Jekyll的克隆（并不代表Jekyll有任何问题），它不是设计来生成博客的（虽然也能很好的胜任此任务）。Waym是一个静态内容生成器，可以用于生成网站、文档、电子书和其他更多的内容。由于它的所有东西都是通过很多灵活的模块（你也可以编写自己的模块）串在一起，所以唯一的限制是你的想象力。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;自带吐槽技能啊，这个Wyam对标的有点像docfx，不过目标跨的太大，扯着蛋了，后面又另起炉灶了，不过如果你只是用blog功能的话还是可以的，目前算是功能完善&lt;/p&gt;
&lt;p&gt;update 2020-03-24:&lt;/p&gt;
&lt;p&gt;用了两周，目前图片，标签系统或多或少有点bug，tags真心一团糟，我fork了一份自己在维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在它的特性当中，尤其让我看中的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/configuration"&gt;配置文件&lt;/a&gt;使用C#脚本写就，这完全是得益于Roslyn的强大&lt;/li&gt;
&lt;li&gt;简单直接的&lt;a href="http://wyam.io/modules/meta"&gt;元数据&lt;/a&gt;使用方式&lt;/li&gt;
&lt;li&gt;支持多种模板引擎和语言，尤其直接内置&lt;a href="http://wyam.io/modules/razor"&gt;Razor&lt;/a&gt;的支持（且Razor的支持是基于ASP.NET MVC 6的源代码的，未来会支持TagHelper） 。当然也有Markdown支持或者扩展自己的模板语言支持。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wyam.io/getting-started/usage"&gt;集成Web Server&lt;/a&gt;方便在编写模板的时候进行预览&lt;/li&gt;
&lt;li&gt;完全&lt;a href="http://wyam.io/getting-started/configuration#nuget"&gt;支持Nuget&lt;/a&gt;，可以在执行生成的过程中，自动下载依赖的Nuget包&lt;/li&gt;
&lt;li&gt;更为重要的，它支持&lt;a href="http://wyam.io/knowledgebase/embedded-use"&gt;嵌入运行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;相对完整清晰的文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Waym其实借鉴了现有其他静态内容生成器的优点和设计，比如FrontMatter的支持（通过Yaml实现）。目前还只是&lt;a href="https://github.com/Wyamio/Wyam/releases/tag/v2.2.9"&gt;v2.2.9&lt;/a&gt;，但是功能完成度还是比较高了，并且你也可以直接pull request参与贡献。源代码地址是：https://github.com/Wyamio/Wyam&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>使用mailkit 和mimekit来发送邮件</title>
			<link>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</link>
			<description>&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2019/10/2017-06-10-use-mailkit-with-mimekit-to-send-email</guid>
			<pubDate>Thu, 24 Oct 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="mailkitmimekit"&gt;&lt;a href="https://github.com/jstedfast/MailKit"&gt;mailkit&lt;/a&gt;和&lt;a href="https://github.com/jstedfast/MimeKit"&gt;mimekit&lt;/a&gt; 是什么&lt;/h2&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mailkit"&gt;What is MailKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MailKit is a cross-platform mail client library built on top of &lt;a href="https://github.com/jstedfast/MimeKit"&gt;MimeKit&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="what-is-mimekit"&gt;What is MimeKit?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;MimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by &lt;a href="https://github.com/jstedfast/MimeKit/blob/master/RFCs.md"&gt;numerous IETF specifications&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;怎么用&lt;/h2&gt;
&lt;p&gt;分为发信和收信功能&lt;/p&gt;
&lt;h3 id="section-1"&gt;发信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; 
	var message = new MimeMessage ();
	message.From.Add (new MailboxAddress (&amp;quot;Joey Tribbiani&amp;quot;, &amp;quot;joey&amp;#64;friends.com&amp;quot;));
	message.To.Add (new MailboxAddress (&amp;quot;Mrs. Chanandler Bong&amp;quot;, &amp;quot;chandler&amp;#64;friends.com&amp;quot;));
	message.Subject = &amp;quot;How you doin'?&amp;quot;;
    message.Body = new TextPart (&amp;quot;plain&amp;quot;) {
				Text = &amp;#64;&amp;quot;Hey Chandler,
I just wanted to let you know that
Monica and I were going to go play some paintball, you in?
-- Joey&amp;quot;
			};

	using (var client = new SmtpClient ()) {
		// For demo-purposes, 
        //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;smtp.friends.com&amp;quot;, 587, false);

		// Note: only needed if the SMTP server requires authentication
		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		client.Send (message);
		client.Disconnect (true);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-2"&gt;收信&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using (var client = new Pop3Client ()) {
	// For demo-purposes, 
    //accept all SSL certificates (in case the server supports STARTTLS)
		client.ServerCertificateValidationCallback = (s,c,h,e) =&amp;gt; true;

		client.Connect (&amp;quot;pop.friends.com&amp;quot;, 110, false);

		client.Authenticate (&amp;quot;joey&amp;quot;, &amp;quot;password&amp;quot;);

		for (int i = 0; i &amp;lt; client.Count; i++) {
			var message = client.GetMessage (i);
			   Console.WriteLine (&amp;quot;Subject: {0}&amp;quot;, message.Subject);
			}
           client.Disconnect (true);
			}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记-2018年版</title>
			<link>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</link>
			<guid>http://blog.robinjiang.com/posts/2018/08/2018-08-16-How-to-Read-a-Book</guid>
			<pubDate>Thu, 16 Aug 2018 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>GELF日志格式漫谈</title>
			<link>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</link>
			<description>&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/06/2017-06-12-about-gelf</guid>
			<pubDate>Mon, 12 Jun 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="gelf"&gt;什么是GELF&lt;/h2&gt;
&lt;p&gt;Graylog扩展日志格式（GELF）是一种日志格式。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;h2 id="structured-events-from-anywhere.compressed-and-chunked"&gt;Structured events from anywhere. Compressed and chunked.&lt;/h2&gt;
&lt;p&gt;The Graylog Extended Log Format (GELF) is a log format that avoids the shortcomings of classic plain syslog:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Limited to length of 1024 bytes – Not much space for payloads like backtraces&lt;/li&gt;
&lt;li&gt;No data types in structured syslog. You don’t know what is a number and what is a string.&lt;/li&gt;
&lt;li&gt;The RFCs are strict enough but there are so many syslog dialects out there that you cannot possibly parse all of them.&lt;/li&gt;
&lt;li&gt;No compression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://docs.graylog.org/en/2.4/pages/gelf.html#gelf-payload-specification"&gt;GELF 规范&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;A GELF message is a JSON string with the following fields:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GELF spec version – “1.1”; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;host&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the name of the host, source or application that sent this message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;short_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a short descriptive message; &lt;strong&gt;MUST&lt;/strong&gt; be set by client library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;full_message&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;a long message that can i.e. contain a backtrace; optional.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Seconds since UNIX epoch with optional decimal places for milliseconds; &lt;em&gt;SHOULD&lt;/em&gt; be set by client library. Will be set to the current timestamp (now) by the server if absent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the level equal to the standard syslog levels; optional, default is 1 (ALERT).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;facility&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;line&lt;/strong&gt; &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the line in a file that caused the error (decimal); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;file&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the file (with path if you want) that caused the error (string); optional, deprecated. Send as additional field instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_[additional field]&lt;/strong&gt; &lt;code&gt;string (UTF-8)&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;every field you send and prefix with an underscore (&lt;code&gt;_&lt;/code&gt;) will be treated as an additional field. Allowed characters in field names are any word character (letter, number, underscore), dashes and dots. The verifying regular expression is: &lt;code&gt;^[\w\.\-]*$&lt;/code&gt;. Libraries SHOULD not allow to send id as additional field (&lt;code&gt;_id&lt;/code&gt;). Graylog server nodes omit this field automatically。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="gelf-1"&gt;GELF 能解决什么问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这是个格式规范，能够让绝大部分日志格式相对统一合理，提高日志可读性。&lt;/li&gt;
&lt;li&gt;这是个json规范，实现比较简单。&lt;/li&gt;
&lt;li&gt;由于无视源文本类型，对于绝大部分日志工具类能很好支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelf-2"&gt;实践中，GELF 存在哪些问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是一个非强制性约束，也就意味着，你需要根据现有业务增加更多的约束条件，比如异常堆栈等标准信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连续日志的追踪需要增加更高级别的支持，类似CorrelationID；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于敏感信息过滤问题，假设要实现用户密码字段的过滤，只能通过正则处理生成后的日志文本来过滤，无法前置过滤；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p timestamp="" controllername="" toekn="" postdata=""&gt;日志模板问题，大部分日志是依据格式化的模板生成的，类似“-:-”；日志模板能够极大的降低传输的数据量，很遗憾，这套规范中很难去扩展实现这种模板支持；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Serilog这类提供更多日志信息的库，容易丢失支持的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gelfserilogtemplate"&gt;GELF+Serilog+template实践&lt;/h2&gt;
&lt;p&gt;repo近期会迁入github&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>关于Metrics，Tracing和Logging</title>
			<link>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</link>
			<description>&lt;p&gt;这是一篇翻译文章&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2017/04/2017-12-04-metrics-tracing-logging</guid>
			<pubDate>Wed, 12 Apr 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;这是一篇翻译文章&lt;/p&gt;
&lt;p&gt;Peter Bourgon 原作： &lt;a href="http://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html"&gt;Metrics, tracing, and logging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，我很荣幸的参加了 2017 分布式追踪峰会(2017 Distributed Tracing Summit)， 并和来自 AWS/X-Ray,
OpenZipkin, OpenTracing, Instana, Datadog, Librato，以及其他更多组织的同仁进行了愉快的沟通和讨论。
其中一个重要的论点，是针对监控项目的范围和定义的。作为一个分布式追踪系统，应该管理日志么?从不同角度看来，到底什么是日志?如何通过一张图形象的定位这些形形色色的系统?&lt;/p&gt;
&lt;p&gt;总体说来，我觉得我们是在一些通用的名词间纠结。我想我们可以通过图表来定义监控的作用域，使各名词的作用范围更明确。 我们使用维恩图(Venn diagram)来描述 Metrics, Tracing, Logging 三个概念的定义。他们三者在某些情况下是重叠的，但是我尽量尝试定义他们的不同。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/01.png" class="img-fluid" alt="Annotated Venn diagram" /&gt;&lt;/p&gt;
&lt;p&gt;Metrics 的特点是，它是可累加的， 他们具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计; 输入 HTTP 请求的数量可以被定义为一个计数器，用于简单累加;请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Logging 的特点是，它描述一些离散的(不连续的)事件。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：应用通过一个滚动的文件输出 Debug 或 Error 信息，并通过日志收集系统，存储到 Elasticsearch 中;
审批明细信息通过 Kafka，存储到数据库(BigTable)中;
又或者，特定请求的元数据信息，从服务请求中剥离出来，发送给一个异常收集服务，如 NewRelic。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tracing 的最大特点就是，它在单次请求的范围内，处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;例如：一次调用远程服务的 RPC 执行过程;一次实际的 SQL 查询语句;一次 HTTP 请求的业务性 ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上述的定义，我们可以标记上图的重叠部分。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/02.png" class="img-fluid" alt="修正的带注释的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;当然，大量的被监控的应用是具有分布式能力(Cloud-native)的应用，逻辑处理在单次请求的范围内完成。因此，讨论追踪的上下文是有意义的。但是，我们注意到，并不是所有的监控系统都绑定在请求的生命周期上的。他们可能是逻辑组件诊断信息、处理过程的生命周期明细信息，这些信息和任何离散的请求时正交关系。&lt;/p&gt;
&lt;p&gt;所以，不是所有的 Metrics 和 Log 都可以被塞进追踪系统的概念中，至少在不经过数据加工处理是不行的。又或者，我们可能发觉使用 Metrics 统计数据，对应用监控有很大帮助，例如 Prometheus 生态，可以量化的实时展现应用视图;相应的，如果我们将 Metrics 统计数据强行使用针对 Log 的管道来处理，将使我们丢失很多特性。&lt;/p&gt;
&lt;p&gt;那么，在这里，我们可以开始对已知的系统进行分类。如：Prometheus，专一的 Metrics 统计系统，随着时间推移，也许会进化为追踪系统，进而进行请求内的指标统计，但不太可能深入到 Log 处理领域。ELK 生态提供 Log 的记录，滚动和聚合，并在其他领域不停的积累更多的特性，并集成进来。&lt;/p&gt;
&lt;p&gt;另外，我发现通过维恩图的方式展现三者关系时，会正巧展现出一个附加效应。在这三个功能域中，Metrics 倾向于更节省资源，因为他会“天然的”压缩数据。相反，日志倾向于无限增加的，会频繁的超出预期的容量。(有另一篇我写的关于这方面的文章，查看，译者注：未翻译)。所以，我们可以在图上，绘制出容量的需求趋势，Metrics 低到 Logging 高，
而 Trace 可能处于他们两的中间位置&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.robinjiang.com/posts/asset/2017-12-04-metrics-tracing-logging/03.png" class="img-fluid" alt="带有梯度的维恩图" /&gt;&lt;/p&gt;
&lt;p&gt;也许，这不是最完美的方式描述这三者的管理，但我从会议现场收到的反馈来看，这个分类还是相当不错的：随着三者的关系越清晰，我们越容易建设性的讨论其他问题。如果你尝试对产品的功能进行定位，你可能也需要这张图。&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记-2017年版</title>
			<link>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</link>
			<guid>http://blog.robinjiang.com/posts/2017/02/2017-02-21-How-to-Read-a-Book</guid>
			<pubDate>Tue, 21 Feb 2017 00:00:00 GMT</pubDate>
		</item>
		<item>
			<title>《如何阅读一本书》读书笔记-2016年</title>
			<link>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</link>
			<description>&lt;p&gt;如何阅读一本书
&lt;img src="s1670978.jpg" class="img-fluid" alt="如何阅读一本书"&gt;
如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;</description>
			<guid>http://blog.robinjiang.com/posts/2016/03/2016-03-15-How-to-Read-a-Book</guid>
			<pubDate>Tue, 15 Mar 2016 00:00:00 GMT</pubDate>
			<content:encoded>&lt;blockquote class="blockquote"&gt;
&lt;p&gt;如何阅读一本书
&lt;img src="s1670978.jpg" class="img-fluid" alt="如何阅读一本书" /&gt;
如何阅读一本书作者: [美] 莫提默·J. 艾德勒 / 查尔斯·范多伦
出版社: 商务印书馆
原作名: How to Read a Book
译者: 郝明义 / 朱衣
出版年: 2004-1
页数: 376
定价: 38.00元
装帧: 平装
ISBN: 9787100040945&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section"&gt;为什么读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;提高阅读效率&lt;/li&gt;
&lt;li&gt;从更高的层次审阅自己的阅读方式，以期获得更具实用性的阅读技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;读了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;阅读的四个层次：基础阅读，检视阅读，分析阅读，主题阅读&lt;/li&gt;
&lt;li&gt;轻重缓急：对于不同的内容需要审时度势，以判定花费的时间和精力，并非所有的内容都需要一字一句的逐个分析&lt;/li&gt;
&lt;li&gt;大部分文本阅读无需达到分析阅读的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;理解了什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果是获取技能或者认知类增长的情况下，主题阅读更有效率&lt;/li&gt;
&lt;li&gt;对于娱乐类型的阅读，建议无脑阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;如何做&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按主题的方式对过往的认知进行归类，并考虑输出成思维导图或技术图谱&lt;/li&gt;
&lt;li&gt;放弃一部分消遣式的阅读&lt;/li&gt;
&lt;li&gt;有必要审视自己的碎片化阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;综合评价&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就这本书而言，翻译有点糟心，考虑继续深读或理解的化，有必要准备英文版本的读&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
	</channel>
</rss>