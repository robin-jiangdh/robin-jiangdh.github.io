<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-12-17T23:19:46.8830331"><meta name="build-number" content="${buildNumber}">       <title>索引优化原则 | blog</title><script id="virtual-toc-data" type="application/json">[]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="索引优化原则 | blog"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="blog Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="/blog/1.0/mysql-2018-04-11-mysql-index-optimization.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="索引优化原则 | blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "/blog/1.0/mysql-2018-04-11-mysql-index-optimization.html#webpage", "url": "/blog/1.0/mysql-2018-04-11-mysql-index-optimization.html", "name": "索引优化原则 | blog", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/blog/#website", "url": "/blog/", "name": "blog Help" }</script><!-- End Schema.org --></head>      <body data-id="mysql_2018-04-11-mysql-index-optimization" data-main-title="索引优化原则" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="post///mysql"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>blog 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="mysql_2018-04-11-mysql-index-optimization"   id="mysql_2018-04-11-mysql-index-optimization.md">索引优化原则</h1>  <ul class="list _ul" id="475dcdf0_244"><li class="list__item" id="475dcdf0_245"><p>最左前缀匹配原则</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="475dcdf0_246"><p id="475dcdf0_247">联合索引，mysql会从做向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</p></aside><ul class="list _ul" id="475dcdf0_248"><li class="list__item" id="475dcdf0_249"><p id="475dcdf0_250">=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p></li><li class="list__item" id="475dcdf0_251"><p id="475dcdf0_252">索引列不能参与计算，保持列&ldquo;干净&rdquo;，比如from_unixtime(create_time) = &rsquo;2014-05-29&rsquo;就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(&rsquo;2014-05-29&rsquo;)</p></li><li class="list__item" id="475dcdf0_253"><p id="475dcdf0_254">使用索引时，索引字段最好小而且唯一，避免select * 的情况</p></li><li class="list__item" id="475dcdf0_255"><p id="475dcdf0_256"><span class="control" id="475dcdf0_257">不冗余原则</span> ：尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可，建立不必要索引会增加MySQL空间。 **基于刚才的最左匹配原则，尽量在原有基础上扩展索引，不要新增索引。 能用单索引，不用联合索引；能用窄索引，不用宽索引；能复用索引，不新建索引 **</p></li><li class="list__item" id="475dcdf0_258"><p id="475dcdf0_259">如果确定有多少条数据，使用 limit 限制一下，MySQL在查找到对应条数的数据的时候，会停止继续查找</p></li><li class="list__item" id="475dcdf0_260"><p id="475dcdf0_261">利用查询缓存，很多时候MySQL会对查询结果进行cache，但是对应&ldquo;动态&rdquo;的数据会不cache，例如：</p><div class="code-block" data-lang="none"         >
无法使用cache
1 SELECT username FROM user WHERE signup_date &gt;= CURDATE() 
可以cache
2 SELECT username FROM user WHERE signup_date &gt;= '2017-05-06' 
</div><p id="475dcdf0_263">当使用了MySQL的一写函数之后，MySQL无法确定结果是易变的，所以不会cache，还有now(),rand()也一样不开启cache</p></li><li class="list__item" id="475dcdf0_264"><p id="475dcdf0_265">join 语法，尽量将小的表放在前面，在需要on的字段上，数据类型保持一致，并设置对应的索引，否则MySQL无法使用索引来join查询</p></li><li class="list__item" id="475dcdf0_266"><p id="475dcdf0_267">在大表上做大量更新时，如果会锁全表，则需要拆分执行，避免长时间锁住表，导致其他请求积累太多（InnoDB 支持行锁，但前提是Where子句需要建立索引，没有索引也一样是锁全表）</p></li></ul><div class="code-block" data-lang="none"         >
  while (1) {
      //每次只做1000条
     mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= '2009-11-01' LIMIT 1000&quot;);
     if (mysql_affected_rows() == 0) {
          // 没得可删了，退出！
          break;
      }
      // 每次都要休息一会儿
      usleep(50000);
  }
</div><ul class="list _ul" id="475dcdf0_269"><li class="list__item" id="475dcdf0_270"><p>最大选择性原则 选择区分度高列做索引 什么是区分度高的字段呢？ 一般两种情况不建议建索引： 1、一两千条甚至几百条，没必要建索引，让查询做全表扫描就好了。 因为不是你建了就一定会走索引，执行计划会选择一个最优的方式，msql辅助索引的叶子节点并不直接存储实际数据，只是主建ID，再通过主键索引二次查找。这么一来全表可能很有可能效率更高。 2、索引选择性较低的情况。 所谓选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值。</p></li></ul><div class="last-modified"> Last modified: 17 十二月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="mysql-2019-11-15-mysql-lock.html">MySQL中select * for update锁表的范围</a>   <a class="navigation-links__next" href="mysql-2017-01-11-mysql-explain-or-desc.html">MySQL 执行计划</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>